{"file_info_response":[{"return_code":1,"file_info":{"name":"src/net/http/http_network_transaction.cc","lines":"1780","size":"63968","language":"c++","type":1,"md5":"f13ed830910a51fc4aafb9adbc2abb24","changelist_num":"c59068590b02e4c25544b62a5a9a5cf6863252b3","mime_type":"text/plain","generated":false,"package_name":"chromium","content":{"text":"// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"net/http/http_network_transaction.h\"\n\n#include \u003cset\u003e\n#include \u003cutility\u003e\n#include \u003cvector\u003e\n\n#include \"base/base64url.h\"\n#include \"base/bind.h\"\n#include \"base/bind_helpers.h\"\n#include \"base/compiler_specific.h\"\n#include \"base/format_macros.h\"\n#include \"base/metrics/field_trial.h\"\n#include \"base/metrics/histogram_macros.h\"\n#include \"base/metrics/sparse_histogram.h\"\n#include \"base/profiler/scoped_tracker.h\"\n#include \"base/stl_util.h\"\n#include \"base/strings/string_number_conversions.h\"\n#include \"base/strings/string_util.h\"\n#include \"base/time/time.h\"\n#include \"base/values.h\"\n#include \"build/build_config.h\"\n#include \"net/base/auth.h\"\n#include \"net/base/host_port_pair.h\"\n#include \"net/base/io_buffer.h\"\n#include \"net/base/load_flags.h\"\n#include \"net/base/load_timing_info.h\"\n#include \"net/base/net_errors.h\"\n#include \"net/base/upload_data_stream.h\"\n#include \"net/base/url_util.h\"\n#include \"net/filter/filter_source_stream.h\"\n#include \"net/http/http_auth.h\"\n#include \"net/http/http_auth_handler.h\"\n#include \"net/http/http_auth_handler_factory.h\"\n#include \"net/http/http_basic_stream.h\"\n#include \"net/http/http_chunked_decoder.h\"\n#include \"net/http/http_network_session.h\"\n#include \"net/http/http_proxy_client_socket.h\"\n#include \"net/http/http_proxy_client_socket_pool.h\"\n#include \"net/http/http_request_headers.h\"\n#include \"net/http/http_request_info.h\"\n#include \"net/http/http_response_headers.h\"\n#include \"net/http/http_response_info.h\"\n#include \"net/http/http_server_properties.h\"\n#include \"net/http/http_status_code.h\"\n#include \"net/http/http_stream.h\"\n#include \"net/http/http_stream_factory.h\"\n#include \"net/http/http_util.h\"\n#include \"net/http/transport_security_state.h\"\n#include \"net/http/url_security_manager.h\"\n#include \"net/log/net_log_event_type.h\"\n#include \"net/proxy/proxy_server.h\"\n#include \"net/socket/client_socket_factory.h\"\n#include \"net/socket/next_proto.h\"\n#include \"net/socket/socks_client_socket_pool.h\"\n#include \"net/socket/transport_client_socket_pool.h\"\n#include \"net/spdy/chromium/spdy_http_stream.h\"\n#include \"net/spdy/chromium/spdy_session.h\"\n#include \"net/spdy/chromium/spdy_session_pool.h\"\n#include \"net/ssl/ssl_cert_request_info.h\"\n#include \"net/ssl/ssl_connection_status_flags.h\"\n#include \"net/ssl/ssl_private_key.h\"\n#include \"net/ssl/token_binding.h\"\n#include \"url/gurl.h\"\n#include \"url/url_canon.h\"\n\nnamespace net {\n\nHttpNetworkTransaction::HttpNetworkTransaction(RequestPriority priority,\n                                               HttpNetworkSession* session)\n    : pending_auth_target_(HttpAuth::AUTH_NONE),\n      io_callback_(base::Bind(\u0026HttpNetworkTransaction::OnIOComplete,\n                              base::Unretained(this))),\n      session_(session),\n      request_(NULL),\n      priority_(priority),\n      headers_valid_(false),\n      request_headers_(),\n      read_buf_len_(0),\n      total_received_bytes_(0),\n      total_sent_bytes_(0),\n      next_state_(STATE_NONE),\n      establishing_tunnel_(false),\n      enable_ip_based_pooling_(true),\n      enable_alternative_services_(true),\n      websocket_handshake_stream_base_create_helper_(NULL),\n      net_error_details_() {}\n\nHttpNetworkTransaction::~HttpNetworkTransaction() {\n  if (stream_.get()) {\n    // TODO(mbelshe): The stream_ should be able to compute whether or not the\n    //                stream should be kept alive.  No reason to compute here\n    //                and pass it in.\n    if (!stream_-\u003eCanReuseConnection() || next_state_ != STATE_NONE) {\n      stream_-\u003eClose(true /* not reusable */);\n    } else if (stream_-\u003eIsResponseBodyComplete()) {\n      // If the response body is complete, we can just reuse the socket.\n      stream_-\u003eClose(false /* reusable */);\n    } else {\n      // Otherwise, we try to drain the response body.\n      HttpStream* stream = stream_.release();\n      stream-\u003eDrain(session_);\n    }\n  }\n  if (request_ \u0026\u0026 request_-\u003eupload_data_stream)\n    request_-\u003eupload_data_stream-\u003eReset();  // Invalidate pending callbacks.\n}\n\nint HttpNetworkTransaction::Start(const HttpRequestInfo* request_info,\n                                  const CompletionCallback\u0026 callback,\n                                  const NetLogWithSource\u0026 net_log) {\n  net_log_ = net_log;\n  request_ = request_info;\n  url_ = request_-\u003eurl;\n\n  // Now that we have an HttpRequestInfo object, update server_ssl_config_.\n  session_-\u003eGetSSLConfig(*request_, \u0026server_ssl_config_, \u0026proxy_ssl_config_);\n\n  if (request_-\u003eload_flags \u0026 LOAD_DISABLE_CERT_REVOCATION_CHECKING) {\n    server_ssl_config_.rev_checking_enabled = false;\n    proxy_ssl_config_.rev_checking_enabled = false;\n  }\n\n  if (request_-\u003eload_flags \u0026 LOAD_PREFETCH)\n    response_.unused_since_prefetch = true;\n\n  next_state_ = STATE_THROTTLE;\n  int rv = DoLoop(OK);\n  if (rv == ERR_IO_PENDING)\n    callback_ = callback;\n  return rv;\n}\n\nint HttpNetworkTransaction::RestartIgnoringLastError(\n    const CompletionCallback\u0026 callback) {\n  DCHECK(!stream_.get());\n  DCHECK(!stream_request_.get());\n  DCHECK_EQ(STATE_NONE, next_state_);\n\n  next_state_ = STATE_CREATE_STREAM;\n\n  int rv = DoLoop(OK);\n  if (rv == ERR_IO_PENDING)\n    callback_ = callback;\n  return rv;\n}\n\nint HttpNetworkTransaction::RestartWithCertificate(\n    X509Certificate* client_cert,\n    SSLPrivateKey* client_private_key,\n    const CompletionCallback\u0026 callback) {\n  // In HandleCertificateRequest(), we always tear down existing stream\n  // requests to force a new connection.  So we shouldn't have one here.\n  DCHECK(!stream_request_.get());\n  DCHECK(!stream_.get());\n  DCHECK_EQ(STATE_NONE, next_state_);\n\n  SSLConfig* ssl_config = response_.cert_request_info-\u003eis_proxy ?\n      \u0026proxy_ssl_config_ : \u0026server_ssl_config_;\n  ssl_config-\u003esend_client_cert = true;\n  ssl_config-\u003eclient_cert = client_cert;\n  ssl_config-\u003eclient_private_key = client_private_key;\n  session_-\u003essl_client_auth_cache()-\u003eAdd(\n      response_.cert_request_info-\u003ehost_and_port, client_cert,\n      client_private_key);\n  // Reset the other member variables.\n  // Note: this is necessary only with SSL renegotiation.\n  ResetStateForRestart();\n  next_state_ = STATE_CREATE_STREAM;\n  int rv = DoLoop(OK);\n  if (rv == ERR_IO_PENDING)\n    callback_ = callback;\n  return rv;\n}\n\nint HttpNetworkTransaction::RestartWithAuth(\n    const AuthCredentials\u0026 credentials, const CompletionCallback\u0026 callback) {\n  HttpAuth::Target target = pending_auth_target_;\n  if (target == HttpAuth::AUTH_NONE) {\n    NOTREACHED();\n    return ERR_UNEXPECTED;\n  }\n  pending_auth_target_ = HttpAuth::AUTH_NONE;\n\n  auth_controllers_[target]-\u003eResetAuth(credentials);\n\n  DCHECK(callback_.is_null());\n\n  int rv = OK;\n  if (target == HttpAuth::AUTH_PROXY \u0026\u0026 establishing_tunnel_) {\n    // In this case, we've gathered credentials for use with proxy\n    // authentication of a tunnel.\n    DCHECK_EQ(STATE_CREATE_STREAM_COMPLETE, next_state_);\n    DCHECK(stream_request_ != NULL);\n    auth_controllers_[target] = NULL;\n    ResetStateForRestart();\n    rv = stream_request_-\u003eRestartTunnelWithProxyAuth();\n  } else {\n    // In this case, we've gathered credentials for the server or the proxy\n    // but it is not during the tunneling phase.\n    DCHECK(stream_request_ == NULL);\n    PrepareForAuthRestart(target);\n    rv = DoLoop(OK);\n  }\n\n  if (rv == ERR_IO_PENDING)\n    callback_ = callback;\n  return rv;\n}\n\nvoid HttpNetworkTransaction::PrepareForAuthRestart(HttpAuth::Target target) {\n  DCHECK(HaveAuth(target));\n  DCHECK(!stream_request_.get());\n\n  bool keep_alive = false;\n  // Even if the server says the connection is keep-alive, we have to be\n  // able to find the end of each response in order to reuse the connection.\n  if (stream_-\u003eCanReuseConnection()) {\n    // If the response body hasn't been completely read, we need to drain\n    // it first.\n    if (!stream_-\u003eIsResponseBodyComplete()) {\n      next_state_ = STATE_DRAIN_BODY_FOR_AUTH_RESTART;\n      read_buf_ = new IOBuffer(kDrainBodyBufferSize);  // A bit bucket.\n      read_buf_len_ = kDrainBodyBufferSize;\n      return;\n    }\n    keep_alive = true;\n  }\n\n  // We don't need to drain the response body, so we act as if we had drained\n  // the response body.\n  DidDrainBodyForAuthRestart(keep_alive);\n}\n\nvoid HttpNetworkTransaction::DidDrainBodyForAuthRestart(bool keep_alive) {\n  DCHECK(!stream_request_.get());\n\n  if (stream_.get()) {\n    total_received_bytes_ += stream_-\u003eGetTotalReceivedBytes();\n    total_sent_bytes_ += stream_-\u003eGetTotalSentBytes();\n    HttpStream* new_stream = NULL;\n    if (keep_alive \u0026\u0026 stream_-\u003eCanReuseConnection()) {\n      // We should call connection_-\u003eset_idle_time(), but this doesn't occur\n      // often enough to be worth the trouble.\n      stream_-\u003eSetConnectionReused();\n      new_stream = stream_-\u003eRenewStreamForAuth();\n    }\n\n    if (!new_stream) {\n      // Close the stream and mark it as not_reusable.  Even in the\n      // keep_alive case, we've determined that the stream_ is not\n      // reusable if new_stream is NULL.\n      stream_-\u003eClose(true);\n      next_state_ = STATE_CREATE_STREAM;\n    } else {\n      // Renewed streams shouldn't carry over sent or received bytes.\n      DCHECK_EQ(0, new_stream-\u003eGetTotalReceivedBytes());\n      DCHECK_EQ(0, new_stream-\u003eGetTotalSentBytes());\n      next_state_ = STATE_INIT_STREAM;\n    }\n    stream_.reset(new_stream);\n  }\n\n  // Reset the other member variables.\n  ResetStateForAuthRestart();\n}\n\nbool HttpNetworkTransaction::IsReadyToRestartForAuth() {\n  return pending_auth_target_ != HttpAuth::AUTH_NONE \u0026\u0026\n      HaveAuth(pending_auth_target_);\n}\n\nint HttpNetworkTransaction::Read(IOBuffer* buf, int buf_len,\n                                 const CompletionCallback\u0026 callback) {\n  DCHECK(buf);\n  DCHECK_LT(0, buf_len);\n\n  scoped_refptr\u003cHttpResponseHeaders\u003e headers(GetResponseHeaders());\n  if (headers_valid_ \u0026\u0026 headers.get() \u0026\u0026 stream_request_.get()) {\n    // We're trying to read the body of the response but we're still trying\n    // to establish an SSL tunnel through an HTTP proxy.  We can't read these\n    // bytes when establishing a tunnel because they might be controlled by\n    // an active network attacker.  We don't worry about this for HTTP\n    // because an active network attacker can already control HTTP sessions.\n    // We reach this case when the user cancels a 407 proxy auth prompt.  We\n    // also don't worry about this for an HTTPS Proxy, because the\n    // communication with the proxy is secure.\n    // See http://crbug.com/8473.\n    DCHECK(proxy_info_.is_http() || proxy_info_.is_https());\n    DCHECK_EQ(headers-\u003eresponse_code(), HTTP_PROXY_AUTHENTICATION_REQUIRED);\n    LOG(WARNING) \u003c\u003c \"Blocked proxy response with status \"\n                 \u003c\u003c headers-\u003eresponse_code() \u003c\u003c \" to CONNECT request for \"\n                 \u003c\u003c GetHostAndPort(url_) \u003c\u003c \".\";\n    return ERR_TUNNEL_CONNECTION_FAILED;\n  }\n\n  // Are we using SPDY or HTTP?\n  next_state_ = STATE_READ_BODY;\n\n  // We have reached the end of Start state machine, reset the requestinfo to\n  // null.\n  // RequestInfo is a member of the HttpTransaction's consumer and is useful\n  // only till final response headers are received. A reset will ensure that\n  // HttpRequestInfo is only used up until final response headers are received.\n  // Resetting is allowed so that the transaction can be disassociated from its\n  // creating consumer in cases where it is shared for writing to the cache.\n  // It is also safe to reset it to null at this point since upload_data_stream\n  // is also not used in the Read state machine.\n  request_ = nullptr;\n\n  read_buf_ = buf;\n  read_buf_len_ = buf_len;\n\n  int rv = DoLoop(OK);\n  if (rv == ERR_IO_PENDING)\n    callback_ = callback;\n  return rv;\n}\n\nvoid HttpNetworkTransaction::StopCaching() {}\n\nbool HttpNetworkTransaction::GetFullRequestHeaders(\n    HttpRequestHeaders* headers) const {\n  // TODO(juliatuttle): Make sure we've populated request_headers_.\n  *headers = request_headers_;\n  return true;\n}\n\nint64_t HttpNetworkTransaction::GetTotalReceivedBytes() const {\n  int64_t total_received_bytes = total_received_bytes_;\n  if (stream_)\n    total_received_bytes += stream_-\u003eGetTotalReceivedBytes();\n  return total_received_bytes;\n}\n\nint64_t HttpNetworkTransaction::GetTotalSentBytes() const {\n  int64_t total_sent_bytes = total_sent_bytes_;\n  if (stream_)\n    total_sent_bytes += stream_-\u003eGetTotalSentBytes();\n  return total_sent_bytes;\n}\n\nvoid HttpNetworkTransaction::DoneReading() {}\n\nconst HttpResponseInfo* HttpNetworkTransaction::GetResponseInfo() const {\n  return \u0026response_;\n}\n\nLoadState HttpNetworkTransaction::GetLoadState() const {\n  // TODO(wtc): Define a new LoadState value for the\n  // STATE_INIT_CONNECTION_COMPLETE state, which delays the HTTP request.\n  switch (next_state_) {\n    case STATE_THROTTLE_COMPLETE:\n      return LOAD_STATE_THROTTLED;\n    case STATE_CREATE_STREAM:\n      return LOAD_STATE_WAITING_FOR_DELEGATE;\n    case STATE_CREATE_STREAM_COMPLETE:\n      return stream_request_-\u003eGetLoadState();\n    case STATE_GENERATE_PROXY_AUTH_TOKEN_COMPLETE:\n    case STATE_GENERATE_SERVER_AUTH_TOKEN_COMPLETE:\n    case STATE_SEND_REQUEST_COMPLETE:\n      return LOAD_STATE_SENDING_REQUEST;\n    case STATE_READ_HEADERS_COMPLETE:\n      return LOAD_STATE_WAITING_FOR_RESPONSE;\n    case STATE_READ_BODY_COMPLETE:\n      return LOAD_STATE_READING_RESPONSE;\n    default:\n      return LOAD_STATE_IDLE;\n  }\n}\n\nvoid HttpNetworkTransaction::SetQuicServerInfo(\n    QuicServerInfo* quic_server_info) {}\n\nbool HttpNetworkTransaction::GetLoadTimingInfo(\n    LoadTimingInfo* load_timing_info) const {\n  if (!stream_ || !stream_-\u003eGetLoadTimingInfo(load_timing_info))\n    return false;\n\n  load_timing_info-\u003eproxy_resolve_start =\n      proxy_info_.proxy_resolve_start_time();\n  load_timing_info-\u003eproxy_resolve_end = proxy_info_.proxy_resolve_end_time();\n  load_timing_info-\u003esend_start = send_start_time_;\n  load_timing_info-\u003esend_end = send_end_time_;\n  return true;\n}\n\nbool HttpNetworkTransaction::GetRemoteEndpoint(IPEndPoint* endpoint) const {\n  if (remote_endpoint_.address().empty())\n    return false;\n\n  *endpoint = remote_endpoint_;\n  return true;\n}\n\nvoid HttpNetworkTransaction::PopulateNetErrorDetails(\n    NetErrorDetails* details) const {\n  *details = net_error_details_;\n  if (stream_)\n    stream_-\u003ePopulateNetErrorDetails(details);\n}\n\nvoid HttpNetworkTransaction::SetPriority(RequestPriority priority) {\n  priority_ = priority;\n\n  // TODO(rdsmith): Note that if any code indirectly executed by\n  // |stream_request_-\u003eSetPriority()| or |stream_-\u003eSetPriority()|\n  // ever implements a throttling mechanism where changing a request's\n  // priority may cause a this or another request to synchronously succeed\n  // or fail, that callback could synchronously delete |*this|, causing\n  // a crash on return to this code.\n  //\n  // |throttle_-\u003eSetPriority()| has exactly the above attributes, which\n  // is why it's the last call in this function.\n\n  if (stream_request_)\n    stream_request_-\u003eSetPriority(priority);\n  if (stream_)\n    stream_-\u003eSetPriority(priority);\n\n  if (throttle_)\n    throttle_-\u003eSetPriority(priority);\n  // The above call may have resulted in deleting |*this|.\n}\n\nvoid HttpNetworkTransaction::SetWebSocketHandshakeStreamCreateHelper(\n    WebSocketHandshakeStreamBase::CreateHelper* create_helper) {\n  websocket_handshake_stream_base_create_helper_ = create_helper;\n}\n\nvoid HttpNetworkTransaction::SetBeforeNetworkStartCallback(\n    const BeforeNetworkStartCallback\u0026 callback) {\n  before_network_start_callback_ = callback;\n}\n\nvoid HttpNetworkTransaction::SetBeforeHeadersSentCallback(\n    const BeforeHeadersSentCallback\u0026 callback) {\n  before_headers_sent_callback_ = callback;\n}\n\nint HttpNetworkTransaction::ResumeNetworkStart() {\n  DCHECK_EQ(next_state_, STATE_CREATE_STREAM);\n  return DoLoop(OK);\n}\n\nvoid HttpNetworkTransaction::OnStreamReady(const SSLConfig\u0026 used_ssl_config,\n                                           const ProxyInfo\u0026 used_proxy_info,\n                                           HttpStream* stream) {\n  DCHECK_EQ(STATE_CREATE_STREAM_COMPLETE, next_state_);\n  DCHECK(stream_request_.get());\n\n  if (stream_) {\n    total_received_bytes_ += stream_-\u003eGetTotalReceivedBytes();\n    total_sent_bytes_ += stream_-\u003eGetTotalSentBytes();\n  }\n  stream_.reset(stream);\n  server_ssl_config_ = used_ssl_config;\n  proxy_info_ = used_proxy_info;\n  response_.was_alpn_negotiated = stream_request_-\u003ewas_alpn_negotiated();\n  response_.alpn_negotiated_protocol =\n      NextProtoToString(stream_request_-\u003enegotiated_protocol());\n  response_.was_fetched_via_spdy = stream_request_-\u003eusing_spdy();\n  response_.was_fetched_via_proxy = !proxy_info_.is_direct();\n  if (response_.was_fetched_via_proxy \u0026\u0026 !proxy_info_.is_empty())\n    response_.proxy_server = proxy_info_.proxy_server();\n  else if (!response_.was_fetched_via_proxy \u0026\u0026 proxy_info_.is_direct())\n    response_.proxy_server = ProxyServer::Direct();\n  else\n    response_.proxy_server = ProxyServer();\n  OnIOComplete(OK);\n}\n\nvoid HttpNetworkTransaction::OnBidirectionalStreamImplReady(\n    const SSLConfig\u0026 used_ssl_config,\n    const ProxyInfo\u0026 used_proxy_info,\n    BidirectionalStreamImpl* stream) {\n  NOTREACHED();\n}\n\nvoid HttpNetworkTransaction::OnWebSocketHandshakeStreamReady(\n    const SSLConfig\u0026 used_ssl_config,\n    const ProxyInfo\u0026 used_proxy_info,\n    WebSocketHandshakeStreamBase* stream) {\n  OnStreamReady(used_ssl_config, used_proxy_info, stream);\n}\n\nvoid HttpNetworkTransaction::OnStreamFailed(int result,\n                                            const SSLConfig\u0026 used_ssl_config) {\n  DCHECK_EQ(STATE_CREATE_STREAM_COMPLETE, next_state_);\n  DCHECK_NE(OK, result);\n  DCHECK(stream_request_.get());\n  DCHECK(!stream_.get());\n  server_ssl_config_ = used_ssl_config;\n\n  OnIOComplete(result);\n}\n\nvoid HttpNetworkTransaction::OnCertificateError(\n    int result,\n    const SSLConfig\u0026 used_ssl_config,\n    const SSLInfo\u0026 ssl_info) {\n  DCHECK_EQ(STATE_CREATE_STREAM_COMPLETE, next_state_);\n  DCHECK_NE(OK, result);\n  DCHECK(stream_request_.get());\n  DCHECK(!stream_.get());\n\n  response_.ssl_info = ssl_info;\n  server_ssl_config_ = used_ssl_config;\n\n  // TODO(mbelshe):  For now, we're going to pass the error through, and that\n  // will close the stream_request in all cases.  This means that we're always\n  // going to restart an entire STATE_CREATE_STREAM, even if the connection is\n  // good and the user chooses to ignore the error.  This is not ideal, but not\n  // the end of the world either.\n\n  OnIOComplete(result);\n}\n\nvoid HttpNetworkTransaction::OnNeedsProxyAuth(\n    const HttpResponseInfo\u0026 proxy_response,\n    const SSLConfig\u0026 used_ssl_config,\n    const ProxyInfo\u0026 used_proxy_info,\n    HttpAuthController* auth_controller) {\n  DCHECK(stream_request_.get());\n  DCHECK_EQ(STATE_CREATE_STREAM_COMPLETE, next_state_);\n\n  establishing_tunnel_ = true;\n  response_.headers = proxy_response.headers;\n  response_.auth_challenge = proxy_response.auth_challenge;\n\n  if (response_.headers.get() \u0026\u0026 !ContentEncodingsValid()) {\n    DoCallback(ERR_CONTENT_DECODING_FAILED);\n    return;\n  }\n\n  headers_valid_ = true;\n  server_ssl_config_ = used_ssl_config;\n  proxy_info_ = used_proxy_info;\n\n  auth_controllers_[HttpAuth::AUTH_PROXY] = auth_controller;\n  pending_auth_target_ = HttpAuth::AUTH_PROXY;\n\n  DoCallback(OK);\n}\n\nvoid HttpNetworkTransaction::OnNeedsClientAuth(\n    const SSLConfig\u0026 used_ssl_config,\n    SSLCertRequestInfo* cert_info) {\n  DCHECK_EQ(STATE_CREATE_STREAM_COMPLETE, next_state_);\n\n  server_ssl_config_ = used_ssl_config;\n  response_.cert_request_info = cert_info;\n  OnIOComplete(ERR_SSL_CLIENT_AUTH_CERT_NEEDED);\n}\n\nvoid HttpNetworkTransaction::OnHttpsProxyTunnelResponse(\n    const HttpResponseInfo\u0026 response_info,\n    const SSLConfig\u0026 used_ssl_config,\n    const ProxyInfo\u0026 used_proxy_info,\n    std::unique_ptr\u003cHttpStream\u003e stream) {\n  DCHECK_EQ(STATE_CREATE_STREAM_COMPLETE, next_state_);\n\n  CopyConnectionAttemptsFromStreamRequest();\n\n  headers_valid_ = true;\n  response_ = response_info;\n  server_ssl_config_ = used_ssl_config;\n  proxy_info_ = used_proxy_info;\n  if (stream_) {\n    total_received_bytes_ += stream_-\u003eGetTotalReceivedBytes();\n    total_sent_bytes_ += stream_-\u003eGetTotalSentBytes();\n  }\n  stream_ = std::move(stream);\n  stream_request_.reset();  // we're done with the stream request\n  OnIOComplete(ERR_HTTPS_PROXY_TUNNEL_RESPONSE);\n}\n\nvoid HttpNetworkTransaction::OnQuicBroken() {\n  net_error_details_.quic_broken = true;\n}\n\nvoid HttpNetworkTransaction::GetConnectionAttempts(\n    ConnectionAttempts* out) const {\n  *out = connection_attempts_;\n}\n\nvoid HttpNetworkTransaction::OnThrottleUnblocked(\n    NetworkThrottleManager::Throttle* throttle) {\n  // TODO(rdsmith): This DCHECK is dependent on the only transition\n  // being from blocked-\u003eunblocked.  That is true right now, but may not\n  // be so in the future.\n  DCHECK_EQ(STATE_THROTTLE_COMPLETE, next_state_);\n\n  net_log_.EndEvent(NetLogEventType::HTTP_TRANSACTION_THROTTLED);\n\n  DoLoop(OK);\n}\n\nbool HttpNetworkTransaction::IsSecureRequest() const {\n  return request_-\u003eurl.SchemeIsCryptographic();\n}\n\nbool HttpNetworkTransaction::IsTokenBindingEnabled() const {\n  if (!IsSecureRequest())\n    return false;\n  SSLInfo ssl_info;\n  stream_-\u003eGetSSLInfo(\u0026ssl_info);\n  return ssl_info.token_binding_negotiated \u0026\u0026\n         ssl_info.token_binding_key_param == TB_PARAM_ECDSAP256 \u0026\u0026\n         session_-\u003eparams().channel_id_service;\n}\n\nvoid HttpNetworkTransaction::RecordTokenBindingSupport() const {\n  // This enum is used for an UMA histogram - do not change or re-use values.\n  enum {\n    DISABLED = 0,\n    CLIENT_ONLY = 1,\n    CLIENT_AND_SERVER = 2,\n    CLIENT_NO_CHANNEL_ID_SERVICE = 3,\n    TOKEN_BINDING_SUPPORT_MAX\n  } supported;\n  if (!IsSecureRequest())\n    return;\n  SSLInfo ssl_info;\n  stream_-\u003eGetSSLInfo(\u0026ssl_info);\n  if (!session_-\u003eparams().enable_token_binding) {\n    supported = DISABLED;\n  } else if (!session_-\u003eparams().channel_id_service) {\n    supported = CLIENT_NO_CHANNEL_ID_SERVICE;\n  } else if (ssl_info.token_binding_negotiated) {\n    supported = CLIENT_AND_SERVER;\n  } else {\n    supported = CLIENT_ONLY;\n  }\n  UMA_HISTOGRAM_ENUMERATION(\"Net.TokenBinding.Support\", supported,\n                            TOKEN_BINDING_SUPPORT_MAX);\n}\n\nbool HttpNetworkTransaction::UsingHttpProxyWithoutTunnel() const {\n  return (proxy_info_.is_http() || proxy_info_.is_https() ||\n          proxy_info_.is_quic()) \u0026\u0026\n         !(request_-\u003eurl.SchemeIs(\"https\") || request_-\u003eurl.SchemeIsWSOrWSS());\n}\n\nvoid HttpNetworkTransaction::DoCallback(int rv) {\n  DCHECK_NE(rv, ERR_IO_PENDING);\n  DCHECK(!callback_.is_null());\n\n  // Since Run may result in Read being called, clear user_callback_ up front.\n  CompletionCallback c = callback_;\n  callback_.Reset();\n  c.Run(rv);\n}\n\nvoid HttpNetworkTransaction::OnIOComplete(int result) {\n  int rv = DoLoop(result);\n  if (rv != ERR_IO_PENDING)\n    DoCallback(rv);\n}\n\nint HttpNetworkTransaction::DoLoop(int result) {\n  DCHECK(next_state_ != STATE_NONE);\n\n  int rv = result;\n  do {\n    State state = next_state_;\n    next_state_ = STATE_NONE;\n    switch (state) {\n      case STATE_THROTTLE:\n        DCHECK_EQ(OK, rv);\n        rv = DoThrottle();\n        break;\n      case STATE_THROTTLE_COMPLETE:\n        DCHECK_EQ(OK, rv);\n        rv = DoThrottleComplete();\n        break;\n      case STATE_NOTIFY_BEFORE_CREATE_STREAM:\n        DCHECK_EQ(OK, rv);\n        rv = DoNotifyBeforeCreateStream();\n        break;\n      case STATE_CREATE_STREAM:\n        DCHECK_EQ(OK, rv);\n        rv = DoCreateStream();\n        break;\n      case STATE_CREATE_STREAM_COMPLETE:\n        // TODO(zhongyi): remove liveness checks when crbug.com/652868 is\n        // solved.\n        net_log_.CrashIfInvalid();\n        rv = DoCreateStreamComplete(rv);\n        net_log_.CrashIfInvalid();\n        break;\n      case STATE_INIT_STREAM:\n        DCHECK_EQ(OK, rv);\n        rv = DoInitStream();\n        break;\n      case STATE_INIT_STREAM_COMPLETE:\n        rv = DoInitStreamComplete(rv);\n        break;\n      case STATE_GENERATE_PROXY_AUTH_TOKEN:\n        DCHECK_EQ(OK, rv);\n        rv = DoGenerateProxyAuthToken();\n        break;\n      case STATE_GENERATE_PROXY_AUTH_TOKEN_COMPLETE:\n        rv = DoGenerateProxyAuthTokenComplete(rv);\n        break;\n      case STATE_GENERATE_SERVER_AUTH_TOKEN:\n        DCHECK_EQ(OK, rv);\n        rv = DoGenerateServerAuthToken();\n        break;\n      case STATE_GENERATE_SERVER_AUTH_TOKEN_COMPLETE:\n        rv = DoGenerateServerAuthTokenComplete(rv);\n        break;\n      case STATE_GET_PROVIDED_TOKEN_BINDING_KEY:\n        DCHECK_EQ(OK, rv);\n        rv = DoGetProvidedTokenBindingKey();\n        break;\n      case STATE_GET_PROVIDED_TOKEN_BINDING_KEY_COMPLETE:\n        rv = DoGetProvidedTokenBindingKeyComplete(rv);\n        break;\n      case STATE_GET_REFERRED_TOKEN_BINDING_KEY:\n        DCHECK_EQ(OK, rv);\n        rv = DoGetReferredTokenBindingKey();\n        break;\n      case STATE_GET_REFERRED_TOKEN_BINDING_KEY_COMPLETE:\n        rv = DoGetReferredTokenBindingKeyComplete(rv);\n        break;\n      case STATE_INIT_REQUEST_BODY:\n        DCHECK_EQ(OK, rv);\n        rv = DoInitRequestBody();\n        break;\n      case STATE_INIT_REQUEST_BODY_COMPLETE:\n        rv = DoInitRequestBodyComplete(rv);\n        break;\n      case STATE_BUILD_REQUEST:\n        DCHECK_EQ(OK, rv);\n        net_log_.BeginEvent(NetLogEventType::HTTP_TRANSACTION_SEND_REQUEST);\n        rv = DoBuildRequest();\n        break;\n      case STATE_BUILD_REQUEST_COMPLETE:\n        rv = DoBuildRequestComplete(rv);\n        break;\n      case STATE_SEND_REQUEST:\n        DCHECK_EQ(OK, rv);\n        rv = DoSendRequest();\n        break;\n      case STATE_SEND_REQUEST_COMPLETE:\n        rv = DoSendRequestComplete(rv);\n        net_log_.EndEventWithNetErrorCode(\n            NetLogEventType::HTTP_TRANSACTION_SEND_REQUEST, rv);\n        break;\n      case STATE_READ_HEADERS:\n        DCHECK_EQ(OK, rv);\n        net_log_.BeginEvent(NetLogEventType::HTTP_TRANSACTION_READ_HEADERS);\n        rv = DoReadHeaders();\n        break;\n      case STATE_READ_HEADERS_COMPLETE:\n        rv = DoReadHeadersComplete(rv);\n        net_log_.EndEventWithNetErrorCode(\n            NetLogEventType::HTTP_TRANSACTION_READ_HEADERS, rv);\n        break;\n      case STATE_READ_BODY:\n        DCHECK_EQ(OK, rv);\n        net_log_.BeginEvent(NetLogEventType::HTTP_TRANSACTION_READ_BODY);\n        rv = DoReadBody();\n        break;\n      case STATE_READ_BODY_COMPLETE:\n        rv = DoReadBodyComplete(rv);\n        net_log_.EndEventWithNetErrorCode(\n            NetLogEventType::HTTP_TRANSACTION_READ_BODY, rv);\n        break;\n      case STATE_DRAIN_BODY_FOR_AUTH_RESTART:\n        DCHECK_EQ(OK, rv);\n        net_log_.BeginEvent(\n            NetLogEventType::HTTP_TRANSACTION_DRAIN_BODY_FOR_AUTH_RESTART);\n        rv = DoDrainBodyForAuthRestart();\n        break;\n      case STATE_DRAIN_BODY_FOR_AUTH_RESTART_COMPLETE:\n        rv = DoDrainBodyForAuthRestartComplete(rv);\n        net_log_.EndEventWithNetErrorCode(\n            NetLogEventType::HTTP_TRANSACTION_DRAIN_BODY_FOR_AUTH_RESTART, rv);\n        break;\n      default:\n        NOTREACHED() \u003c\u003c \"bad state\";\n        rv = ERR_FAILED;\n        break;\n    }\n  } while (rv != ERR_IO_PENDING \u0026\u0026 next_state_ != STATE_NONE);\n\n  return rv;\n}\n\nint HttpNetworkTransaction::DoThrottle() {\n  DCHECK(!throttle_);\n  throttle_ = session_-\u003ethrottler()-\u003eCreateThrottle(\n      this, priority_, (request_-\u003eload_flags \u0026 LOAD_IGNORE_LIMITS) != 0);\n  next_state_ = STATE_THROTTLE_COMPLETE;\n\n  if (throttle_-\u003eIsBlocked()) {\n    net_log_.BeginEvent(NetLogEventType::HTTP_TRANSACTION_THROTTLED);\n    return ERR_IO_PENDING;\n  }\n\n  return OK;\n}\n\nint HttpNetworkTransaction::DoThrottleComplete() {\n  DCHECK(throttle_);\n  DCHECK(!throttle_-\u003eIsBlocked());\n\n  next_state_ = STATE_NOTIFY_BEFORE_CREATE_STREAM;\n\n  return OK;\n}\n\nint HttpNetworkTransaction::DoNotifyBeforeCreateStream() {\n  next_state_ = STATE_CREATE_STREAM;\n  bool defer = false;\n  if (!before_network_start_callback_.is_null())\n    before_network_start_callback_.Run(\u0026defer);\n  if (!defer)\n    return OK;\n  return ERR_IO_PENDING;\n}\n\nint HttpNetworkTransaction::DoCreateStream() {\n  // TODO(mmenke): Remove ScopedTracker below once crbug.com/424359 is fixed.\n  tracked_objects::ScopedTracker tracking_profile(\n      FROM_HERE_WITH_EXPLICIT_FUNCTION(\n          \"424359 HttpNetworkTransaction::DoCreateStream\"));\n\n  response_.network_accessed = true;\n\n  next_state_ = STATE_CREATE_STREAM_COMPLETE;\n  // IP based pooling is only enabled on a retry after 421 Misdirected Request\n  // is received. Alternative Services are also disabled in this case (though\n  // they can also be disabled when retrying after a QUIC error).\n  if (!enable_ip_based_pooling_)\n    DCHECK(!enable_alternative_services_);\n  if (ForWebSocketHandshake()) {\n    stream_request_.reset(\n        session_-\u003ehttp_stream_factory_for_websocket()\n            -\u003eRequestWebSocketHandshakeStream(\n                *request_, priority_, server_ssl_config_, proxy_ssl_config_,\n                this, websocket_handshake_stream_base_create_helper_,\n                enable_ip_based_pooling_, enable_alternative_services_,\n                net_log_));\n  } else {\n    stream_request_.reset(session_-\u003ehttp_stream_factory()-\u003eRequestStream(\n        *request_, priority_, server_ssl_config_, proxy_ssl_config_, this,\n        enable_ip_based_pooling_, enable_alternative_services_, net_log_));\n  }\n  DCHECK(stream_request_.get());\n  return ERR_IO_PENDING;\n}\n\nint HttpNetworkTransaction::DoCreateStreamComplete(int result) {\n  // If |result| is ERR_HTTPS_PROXY_TUNNEL_RESPONSE, then\n  // DoCreateStreamComplete is being called from OnHttpsProxyTunnelResponse,\n  // which resets the stream request first. Therefore, we have to grab the\n  // connection attempts in *that* function instead of here in that case.\n  if (result != ERR_HTTPS_PROXY_TUNNEL_RESPONSE)\n    CopyConnectionAttemptsFromStreamRequest();\n\n  if (result == OK) {\n    next_state_ = STATE_INIT_STREAM;\n    DCHECK(stream_.get());\n  } else if (result == ERR_SSL_CLIENT_AUTH_CERT_NEEDED) {\n    result = HandleCertificateRequest(result);\n  } else if (result == ERR_HTTPS_PROXY_TUNNEL_RESPONSE) {\n    // Return OK and let the caller read the proxy's error page\n    next_state_ = STATE_NONE;\n    return OK;\n  } else if (result == ERR_HTTP_1_1_REQUIRED ||\n             result == ERR_PROXY_HTTP_1_1_REQUIRED) {\n    return HandleHttp11Required(result);\n  }\n\n  // Handle possible handshake errors that may have occurred if the stream\n  // used SSL for one or more of the layers.\n  result = HandleSSLHandshakeError(result);\n\n  // At this point we are done with the stream_request_.\n  stream_request_.reset();\n  return result;\n}\n\nint HttpNetworkTransaction::DoInitStream() {\n  DCHECK(stream_.get());\n  next_state_ = STATE_INIT_STREAM_COMPLETE;\n\n  stream_-\u003eGetRemoteEndpoint(\u0026remote_endpoint_);\n\n  return stream_-\u003eInitializeStream(request_, priority_, net_log_, io_callback_);\n}\n\nint HttpNetworkTransaction::DoInitStreamComplete(int result) {\n  if (result == OK) {\n    next_state_ = STATE_GENERATE_PROXY_AUTH_TOKEN;\n  } else {\n    if (result \u003c 0)\n      result = HandleIOError(result);\n\n    // The stream initialization failed, so this stream will never be useful.\n    if (stream_) {\n      total_received_bytes_ += stream_-\u003eGetTotalReceivedBytes();\n      total_sent_bytes_ += stream_-\u003eGetTotalSentBytes();\n    }\n    CacheNetErrorDetailsAndResetStream();\n  }\n\n  return result;\n}\n\nint HttpNetworkTransaction::DoGenerateProxyAuthToken() {\n  next_state_ = STATE_GENERATE_PROXY_AUTH_TOKEN_COMPLETE;\n  if (!ShouldApplyProxyAuth())\n    return OK;\n  HttpAuth::Target target = HttpAuth::AUTH_PROXY;\n  if (!auth_controllers_[target].get())\n    auth_controllers_[target] =\n        new HttpAuthController(target,\n                               AuthURL(target),\n                               session_-\u003ehttp_auth_cache(),\n                               session_-\u003ehttp_auth_handler_factory());\n  return auth_controllers_[target]-\u003eMaybeGenerateAuthToken(request_,\n                                                           io_callback_,\n                                                           net_log_);\n}\n\nint HttpNetworkTransaction::DoGenerateProxyAuthTokenComplete(int rv) {\n  DCHECK_NE(ERR_IO_PENDING, rv);\n  if (rv == OK)\n    next_state_ = STATE_GENERATE_SERVER_AUTH_TOKEN;\n  return rv;\n}\n\nint HttpNetworkTransaction::DoGenerateServerAuthToken() {\n  next_state_ = STATE_GENERATE_SERVER_AUTH_TOKEN_COMPLETE;\n  HttpAuth::Target target = HttpAuth::AUTH_SERVER;\n  if (!auth_controllers_[target].get()) {\n    auth_controllers_[target] =\n        new HttpAuthController(target,\n                               AuthURL(target),\n                               session_-\u003ehttp_auth_cache(),\n                               session_-\u003ehttp_auth_handler_factory());\n    if (request_-\u003eload_flags \u0026 LOAD_DO_NOT_USE_EMBEDDED_IDENTITY)\n      auth_controllers_[target]-\u003eDisableEmbeddedIdentity();\n  }\n  if (!ShouldApplyServerAuth())\n    return OK;\n  return auth_controllers_[target]-\u003eMaybeGenerateAuthToken(request_,\n                                                           io_callback_,\n                                                           net_log_);\n}\n\nint HttpNetworkTransaction::DoGenerateServerAuthTokenComplete(int rv) {\n  DCHECK_NE(ERR_IO_PENDING, rv);\n  if (rv == OK)\n    next_state_ = STATE_GET_PROVIDED_TOKEN_BINDING_KEY;\n  return rv;\n}\n\nint HttpNetworkTransaction::DoGetProvidedTokenBindingKey() {\n  next_state_ = STATE_GET_PROVIDED_TOKEN_BINDING_KEY_COMPLETE;\n  if (!IsTokenBindingEnabled())\n    return OK;\n\n  net_log_.BeginEvent(NetLogEventType::HTTP_TRANSACTION_GET_TOKEN_BINDING_KEY);\n  ChannelIDService* channel_id_service = session_-\u003eparams().channel_id_service;\n  return channel_id_service-\u003eGetOrCreateChannelID(\n      request_-\u003eurl.host(), \u0026provided_token_binding_key_, io_callback_,\n      \u0026token_binding_request_);\n}\n\nint HttpNetworkTransaction::DoGetProvidedTokenBindingKeyComplete(int rv) {\n  DCHECK_NE(ERR_IO_PENDING, rv);\n  if (IsTokenBindingEnabled()) {\n    net_log_.EndEventWithNetErrorCode(\n        NetLogEventType::HTTP_TRANSACTION_GET_TOKEN_BINDING_KEY, rv);\n  }\n\n  if (rv == OK)\n    next_state_ = STATE_GET_REFERRED_TOKEN_BINDING_KEY;\n  return rv;\n}\n\nint HttpNetworkTransaction::DoGetReferredTokenBindingKey() {\n  next_state_ = STATE_GET_REFERRED_TOKEN_BINDING_KEY_COMPLETE;\n  if (!IsTokenBindingEnabled() || request_-\u003etoken_binding_referrer.empty())\n    return OK;\n\n  net_log_.BeginEvent(NetLogEventType::HTTP_TRANSACTION_GET_TOKEN_BINDING_KEY);\n  ChannelIDService* channel_id_service = session_-\u003eparams().channel_id_service;\n  return channel_id_service-\u003eGetOrCreateChannelID(\n      request_-\u003etoken_binding_referrer, \u0026referred_token_binding_key_,\n      io_callback_, \u0026token_binding_request_);\n}\n\nint HttpNetworkTransaction::DoGetReferredTokenBindingKeyComplete(int rv) {\n  DCHECK_NE(ERR_IO_PENDING, rv);\n  if (IsTokenBindingEnabled() \u0026\u0026 !request_-\u003etoken_binding_referrer.empty()) {\n    net_log_.EndEventWithNetErrorCode(\n        NetLogEventType::HTTP_TRANSACTION_GET_TOKEN_BINDING_KEY, rv);\n  }\n  if (rv == OK)\n    next_state_ = STATE_INIT_REQUEST_BODY;\n  return rv;\n}\n\nint HttpNetworkTransaction::BuildRequestHeaders(\n    bool using_http_proxy_without_tunnel) {\n  request_headers_.SetHeader(HttpRequestHeaders::kHost,\n                             GetHostAndOptionalPort(request_-\u003eurl));\n\n  // For compat with HTTP/1.0 servers and proxies:\n  if (using_http_proxy_without_tunnel) {\n    request_headers_.SetHeader(HttpRequestHeaders::kProxyConnection,\n                               \"keep-alive\");\n  } else {\n    request_headers_.SetHeader(HttpRequestHeaders::kConnection, \"keep-alive\");\n  }\n\n  // Add a content length header?\n  if (request_-\u003eupload_data_stream) {\n    if (request_-\u003eupload_data_stream-\u003eis_chunked()) {\n      request_headers_.SetHeader(\n          HttpRequestHeaders::kTransferEncoding, \"chunked\");\n    } else {\n      request_headers_.SetHeader(\n          HttpRequestHeaders::kContentLength,\n          base::Uint64ToString(request_-\u003eupload_data_stream-\u003esize()));\n    }\n  } else if (request_-\u003emethod == \"POST\" || request_-\u003emethod == \"PUT\") {\n    // An empty POST/PUT request still needs a content length.  As for HEAD,\n    // IE and Safari also add a content length header.  Presumably it is to\n    // support sending a HEAD request to an URL that only expects to be sent a\n    // POST or some other method that normally would have a message body.\n    // Firefox (40.0) does not send the header, and RFC 7230 \u0026 7231\n    // specify that it should not be sent due to undefined behavior.\n    request_headers_.SetHeader(HttpRequestHeaders::kContentLength, \"0\");\n  }\n\n  RecordTokenBindingSupport();\n  if (provided_token_binding_key_) {\n    std::string token_binding_header;\n    int rv = BuildTokenBindingHeader(\u0026token_binding_header);\n    if (rv != OK)\n      return rv;\n    request_headers_.SetHeader(HttpRequestHeaders::kTokenBinding,\n                               token_binding_header);\n  }\n\n  // Honor load flags that impact proxy caches.\n  if (request_-\u003eload_flags \u0026 LOAD_BYPASS_CACHE) {\n    request_headers_.SetHeader(HttpRequestHeaders::kPragma, \"no-cache\");\n    request_headers_.SetHeader(HttpRequestHeaders::kCacheControl, \"no-cache\");\n  } else if (request_-\u003eload_flags \u0026 LOAD_VALIDATE_CACHE) {\n    request_headers_.SetHeader(HttpRequestHeaders::kCacheControl, \"max-age=0\");\n  }\n\n  if (ShouldApplyProxyAuth() \u0026\u0026 HaveAuth(HttpAuth::AUTH_PROXY))\n    auth_controllers_[HttpAuth::AUTH_PROXY]-\u003eAddAuthorizationHeader(\n        \u0026request_headers_);\n  if (ShouldApplyServerAuth() \u0026\u0026 HaveAuth(HttpAuth::AUTH_SERVER))\n    auth_controllers_[HttpAuth::AUTH_SERVER]-\u003eAddAuthorizationHeader(\n        \u0026request_headers_);\n\n  request_headers_.MergeFrom(request_-\u003eextra_headers);\n\n  if (!before_headers_sent_callback_.is_null())\n    before_headers_sent_callback_.Run(proxy_info_, \u0026request_headers_);\n\n  response_.did_use_http_auth =\n      request_headers_.HasHeader(HttpRequestHeaders::kAuthorization) ||\n      request_headers_.HasHeader(HttpRequestHeaders::kProxyAuthorization);\n  return OK;\n}\n\nint HttpNetworkTransaction::BuildTokenBindingHeader(std::string* out) {\n  base::TimeTicks start = base::TimeTicks::Now();\n  std::vector\u003cuint8_t\u003e signed_ekm;\n  int rv = stream_-\u003eGetTokenBindingSignature(provided_token_binding_key_.get(),\n                                             TokenBindingType::PROVIDED,\n                                             \u0026signed_ekm);\n  if (rv != OK)\n    return rv;\n  std::string provided_token_binding;\n  rv = BuildTokenBinding(TokenBindingType::PROVIDED,\n                         provided_token_binding_key_.get(), signed_ekm,\n                         \u0026provided_token_binding);\n  if (rv != OK)\n    return rv;\n\n  std::vector\u003cbase::StringPiece\u003e token_bindings;\n  token_bindings.push_back(provided_token_binding);\n\n  std::string referred_token_binding;\n  if (referred_token_binding_key_) {\n    std::vector\u003cuint8_t\u003e referred_signed_ekm;\n    int rv = stream_-\u003eGetTokenBindingSignature(\n        referred_token_binding_key_.get(), TokenBindingType::REFERRED,\n        \u0026referred_signed_ekm);\n    if (rv != OK)\n      return rv;\n    rv = BuildTokenBinding(TokenBindingType::REFERRED,\n                           referred_token_binding_key_.get(),\n                           referred_signed_ekm, \u0026referred_token_binding);\n    if (rv != OK)\n      return rv;\n    token_bindings.push_back(referred_token_binding);\n  }\n  std::string header;\n  rv = BuildTokenBindingMessageFromTokenBindings(token_bindings, \u0026header);\n  if (rv != OK)\n    return rv;\n  base::Base64UrlEncode(header, base::Base64UrlEncodePolicy::OMIT_PADDING, out);\n  base::TimeDelta header_creation_time = base::TimeTicks::Now() - start;\n  UMA_HISTOGRAM_CUSTOM_TIMES(\"Net.TokenBinding.HeaderCreationTime\",\n                             header_creation_time,\n                             base::TimeDelta::FromMilliseconds(1),\n                             base::TimeDelta::FromMinutes(1), 50);\n  return OK;\n}\n\nint HttpNetworkTransaction::DoInitRequestBody() {\n  next_state_ = STATE_INIT_REQUEST_BODY_COMPLETE;\n  int rv = OK;\n  if (request_-\u003eupload_data_stream)\n    rv = request_-\u003eupload_data_stream-\u003eInit(io_callback_, net_log_);\n  return rv;\n}\n\nint HttpNetworkTransaction::DoInitRequestBodyComplete(int result) {\n  if (result == OK)\n    next_state_ = STATE_BUILD_REQUEST;\n  return result;\n}\n\nint HttpNetworkTransaction::DoBuildRequest() {\n  next_state_ = STATE_BUILD_REQUEST_COMPLETE;\n  headers_valid_ = false;\n\n  // This is constructed lazily (instead of within our Start method), so that\n  // we have proxy info available.\n  if (request_headers_.IsEmpty()) {\n    bool using_http_proxy_without_tunnel = UsingHttpProxyWithoutTunnel();\n    return BuildRequestHeaders(using_http_proxy_without_tunnel);\n  }\n\n  return OK;\n}\n\nint HttpNetworkTransaction::DoBuildRequestComplete(int result) {\n  if (result == OK)\n    next_state_ = STATE_SEND_REQUEST;\n  return result;\n}\n\nint HttpNetworkTransaction::DoSendRequest() {\n  // TODO(mmenke): Remove ScopedTracker below once crbug.com/424359 is fixed.\n  tracked_objects::ScopedTracker tracking_profile(\n      FROM_HERE_WITH_EXPLICIT_FUNCTION(\n          \"424359 HttpNetworkTransaction::DoSendRequest\"));\n\n  send_start_time_ = base::TimeTicks::Now();\n  next_state_ = STATE_SEND_REQUEST_COMPLETE;\n\n  return stream_-\u003eSendRequest(request_headers_, \u0026response_, io_callback_);\n}\n\nint HttpNetworkTransaction::DoSendRequestComplete(int result) {\n  send_end_time_ = base::TimeTicks::Now();\n\n  if (result == ERR_HTTP_1_1_REQUIRED ||\n      result == ERR_PROXY_HTTP_1_1_REQUIRED) {\n    return HandleHttp11Required(result);\n  }\n\n  if (result \u003c 0)\n    return HandleIOError(result);\n  next_state_ = STATE_READ_HEADERS;\n  return OK;\n}\n\nint HttpNetworkTransaction::DoReadHeaders() {\n  next_state_ = STATE_READ_HEADERS_COMPLETE;\n  return stream_-\u003eReadResponseHeaders(io_callback_);\n}\n\nint HttpNetworkTransaction::DoReadHeadersComplete(int result) {\n  // We can get a certificate error or ERR_SSL_CLIENT_AUTH_CERT_NEEDED here\n  // due to SSL renegotiation.\n  if (IsCertificateError(result)) {\n    // We don't handle a certificate error during SSL renegotiation, so we\n    // have to return an error that's not in the certificate error range\n    // (-2xx).\n    LOG(ERROR) \u003c\u003c \"Got a server certificate with error \" \u003c\u003c result\n               \u003c\u003c \" during SSL renegotiation\";\n    result = ERR_CERT_ERROR_IN_SSL_RENEGOTIATION;\n  } else if (result == ERR_SSL_CLIENT_AUTH_CERT_NEEDED) {\n    // TODO(wtc): Need a test case for this code path!\n    DCHECK(stream_.get());\n    DCHECK(IsSecureRequest());\n    response_.cert_request_info = new SSLCertRequestInfo;\n    stream_-\u003eGetSSLCertRequestInfo(response_.cert_request_info.get());\n    result = HandleCertificateRequest(result);\n    if (result == OK)\n      return result;\n  }\n\n  if (result == ERR_HTTP_1_1_REQUIRED ||\n      result == ERR_PROXY_HTTP_1_1_REQUIRED) {\n    return HandleHttp11Required(result);\n  }\n\n  // ERR_CONNECTION_CLOSED is treated differently at this point; if partial\n  // response headers were received, we do the best we can to make sense of it\n  // and send it back up the stack.\n  //\n  // TODO(davidben): Consider moving this to HttpBasicStream, It's a little\n  // bizarre for SPDY. Assuming this logic is useful at all.\n  // TODO(davidben): Bubble the error code up so we do not cache?\n  if (result == ERR_CONNECTION_CLOSED \u0026\u0026 response_.headers.get())\n    result = OK;\n\n  if (result \u003c 0)\n    return HandleIOError(result);\n\n  DCHECK(response_.headers.get());\n\n  if (response_.headers.get() \u0026\u0026 !ContentEncodingsValid())\n    return ERR_CONTENT_DECODING_FAILED;\n\n  // On a 408 response from the server (\"Request Timeout\") on a stale socket,\n  // retry the request.\n  // Headers can be NULL because of http://crbug.com/384554.\n  if (response_.headers.get() \u0026\u0026\n      response_.headers-\u003eresponse_code() == HTTP_REQUEST_TIMEOUT \u0026\u0026\n      stream_-\u003eIsConnectionReused()) {\n    net_log_.AddEventWithNetErrorCode(\n        NetLogEventType::HTTP_TRANSACTION_RESTART_AFTER_ERROR,\n        response_.headers-\u003eresponse_code());\n    // This will close the socket - it would be weird to try and reuse it, even\n    // if the server doesn't actually close it.\n    ResetConnectionAndRequestForResend();\n    return OK;\n  }\n\n  // Like Net.HttpResponseCode, but only for MAIN_FRAME loads.\n  if (request_-\u003eload_flags \u0026 LOAD_MAIN_FRAME_DEPRECATED) {\n    const int response_code = response_.headers-\u003eresponse_code();\n    UMA_HISTOGRAM_ENUMERATION(\n        \"Net.HttpResponseCode_Nxx_MainFrame\", response_code/100, 10);\n  }\n\n  net_log_.AddEvent(\n      NetLogEventType::HTTP_TRANSACTION_READ_RESPONSE_HEADERS,\n      base::Bind(\u0026HttpResponseHeaders::NetLogCallback, response_.headers));\n\n  if (response_.headers-\u003eGetHttpVersion() \u003c HttpVersion(1, 0)) {\n    // HTTP/0.9 doesn't support the PUT method, so lack of response headers\n    // indicates a buggy server.  See:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=193921\n    if (request_-\u003emethod == \"PUT\")\n      return ERR_METHOD_NOT_SUPPORTED;\n  }\n\n  // Check for an intermediate 100 Continue response.  An origin server is\n  // allowed to send this response even if we didn't ask for it, so we just\n  // need to skip over it.\n  // We treat any other 1xx in this same way (although in practice getting\n  // a 1xx that isn't a 100 is rare).\n  // Unless this is a WebSocket request, in which case we pass it on up.\n  if (response_.headers-\u003eresponse_code() / 100 == 1 \u0026\u0026\n      !ForWebSocketHandshake()) {\n    response_.headers = new HttpResponseHeaders(std::string());\n    next_state_ = STATE_READ_HEADERS;\n    return OK;\n  }\n\n  if (response_.headers-\u003eresponse_code() == 421 \u0026\u0026\n      (enable_ip_based_pooling_ || enable_alternative_services_)) {\n    // Retry the request with both IP based pooling and Alternative Services\n    // disabled.\n    enable_ip_based_pooling_ = false;\n    enable_alternative_services_ = false;\n    net_log_.AddEvent(\n        NetLogEventType::HTTP_TRANSACTION_RESTART_MISDIRECTED_REQUEST);\n    ResetConnectionAndRequestForResend();\n    return OK;\n  }\n\n  if (IsSecureRequest()) {\n    session_-\u003ehttp_stream_factory()-\u003eProcessAlternativeServices(\n        session_, response_.headers.get(), url::SchemeHostPort(request_-\u003eurl));\n  }\n\n  if (IsSecureRequest())\n    stream_-\u003eGetSSLInfo(\u0026response_.ssl_info);\n\n  int rv = HandleAuthChallenge();\n  if (rv != OK)\n    return rv;\n\n  headers_valid_ = true;\n  return OK;\n}\n\nint HttpNetworkTransaction::DoReadBody() {\n  DCHECK(read_buf_.get());\n  DCHECK_GT(read_buf_len_, 0);\n  DCHECK(stream_ != NULL);\n\n  next_state_ = STATE_READ_BODY_COMPLETE;\n  return stream_-\u003eReadResponseBody(\n      read_buf_.get(), read_buf_len_, io_callback_);\n}\n\nint HttpNetworkTransaction::DoReadBodyComplete(int result) {\n  // We are done with the Read call.\n  bool done = false;\n  if (result \u003c= 0) {\n    DCHECK_NE(ERR_IO_PENDING, result);\n    done = true;\n  }\n\n  // Clean up connection if we are done.\n  if (done) {\n    // Note: Just because IsResponseBodyComplete is true, we're not\n    // necessarily \"done\".  We're only \"done\" when it is the last\n    // read on this HttpNetworkTransaction, which will be signified\n    // by a zero-length read.\n    // TODO(mbelshe): The keep-alive property is really a property of\n    //    the stream.  No need to compute it here just to pass back\n    //    to the stream's Close function.\n    bool keep_alive =\n        stream_-\u003eIsResponseBodyComplete() \u0026\u0026 stream_-\u003eCanReuseConnection();\n\n    stream_-\u003eClose(!keep_alive);\n    // Note: we don't reset the stream here.  We've closed it, but we still\n    // need it around so that callers can call methods such as\n    // GetUploadProgress() and have them be meaningful.\n    // TODO(mbelshe): This means we closed the stream here, and we close it\n    // again in ~HttpNetworkTransaction.  Clean that up.\n\n    // The next Read call will return 0 (EOF).\n\n    // This transaction was successful. If it had been retried because of an\n    // error with an alternative service, mark that alternative service broken.\n    if (!enable_alternative_services_ \u0026\u0026\n        retried_alternative_service_.protocol != kProtoUnknown) {\n      session_-\u003ehttp_server_properties()-\u003eMarkAlternativeServiceBroken(\n          retried_alternative_service_);\n    }\n  }\n\n  // Clear these to avoid leaving around old state.\n  read_buf_ = NULL;\n  read_buf_len_ = 0;\n\n  return result;\n}\n\nint HttpNetworkTransaction::DoDrainBodyForAuthRestart() {\n  // This method differs from DoReadBody only in the next_state_.  So we just\n  // call DoReadBody and override the next_state_.  Perhaps there is a more\n  // elegant way for these two methods to share code.\n  int rv = DoReadBody();\n  DCHECK(next_state_ == STATE_READ_BODY_COMPLETE);\n  next_state_ = STATE_DRAIN_BODY_FOR_AUTH_RESTART_COMPLETE;\n  return rv;\n}\n\n// TODO(wtc): This method and the DoReadBodyComplete method are almost\n// the same.  Figure out a good way for these two methods to share code.\nint HttpNetworkTransaction::DoDrainBodyForAuthRestartComplete(int result) {\n  // keep_alive defaults to true because the very reason we're draining the\n  // response body is to reuse the connection for auth restart.\n  bool done = false, keep_alive = true;\n  if (result \u003c 0) {\n    // Error or closed connection while reading the socket.\n    done = true;\n    keep_alive = false;\n  } else if (stream_-\u003eIsResponseBodyComplete()) {\n    done = true;\n  }\n\n  if (done) {\n    DidDrainBodyForAuthRestart(keep_alive);\n  } else {\n    // Keep draining.\n    next_state_ = STATE_DRAIN_BODY_FOR_AUTH_RESTART;\n  }\n\n  return OK;\n}\n\nint HttpNetworkTransaction::HandleCertificateRequest(int error) {\n  // There are two paths through which the server can request a certificate\n  // from us.  The first is during the initial handshake, the second is\n  // during SSL renegotiation.\n  //\n  // In both cases, we want to close the connection before proceeding.\n  // We do this for two reasons:\n  //   First, we don't want to keep the connection to the server hung for a\n  //   long time while the user selects a certificate.\n  //   Second, even if we did keep the connection open, NSS has a bug where\n  //   restarting the handshake for ClientAuth is currently broken.\n  DCHECK_EQ(error, ERR_SSL_CLIENT_AUTH_CERT_NEEDED);\n\n  if (stream_.get()) {\n    // Since we already have a stream, we're being called as part of SSL\n    // renegotiation.\n    DCHECK(!stream_request_.get());\n    total_received_bytes_ += stream_-\u003eGetTotalReceivedBytes();\n    total_sent_bytes_ += stream_-\u003eGetTotalSentBytes();\n    stream_-\u003eClose(true);\n    CacheNetErrorDetailsAndResetStream();\n  }\n\n  // The server is asking for a client certificate during the initial\n  // handshake.\n  stream_request_.reset();\n\n  // If the user selected one of the certificates in client_certs or declined\n  // to provide one for this server before, use the past decision\n  // automatically.\n  scoped_refptr\u003cX509Certificate\u003e client_cert;\n  scoped_refptr\u003cSSLPrivateKey\u003e client_private_key;\n  bool found_cached_cert = session_-\u003essl_client_auth_cache()-\u003eLookup(\n      response_.cert_request_info-\u003ehost_and_port, \u0026client_cert,\n      \u0026client_private_key);\n  if (!found_cached_cert)\n    return error;\n\n  // Check that the certificate selected is still a certificate the server\n  // is likely to accept, based on the criteria supplied in the\n  // CertificateRequest message.\n  if (client_cert.get()) {\n    const std::vector\u003cstd::string\u003e\u0026 cert_authorities =\n        response_.cert_request_info-\u003ecert_authorities;\n\n    bool cert_still_valid = cert_authorities.empty() ||\n        client_cert-\u003eIsIssuedByEncoded(cert_authorities);\n    if (!cert_still_valid)\n      return error;\n  }\n\n  // TODO(davidben): Add a unit test which covers this path; we need to be\n  // able to send a legitimate certificate and also bypass/clear the\n  // SSL session cache.\n  SSLConfig* ssl_config = response_.cert_request_info-\u003eis_proxy ?\n      \u0026proxy_ssl_config_ : \u0026server_ssl_config_;\n  ssl_config-\u003esend_client_cert = true;\n  ssl_config-\u003eclient_cert = client_cert;\n  ssl_config-\u003eclient_private_key = client_private_key;\n  next_state_ = STATE_CREATE_STREAM;\n  // Reset the other member variables.\n  // Note: this is necessary only with SSL renegotiation.\n  ResetStateForRestart();\n  return OK;\n}\n\nint HttpNetworkTransaction::HandleHttp11Required(int error) {\n  DCHECK(error == ERR_HTTP_1_1_REQUIRED ||\n         error == ERR_PROXY_HTTP_1_1_REQUIRED);\n\n  if (error == ERR_HTTP_1_1_REQUIRED) {\n    HttpServerProperties::ForceHTTP11(\u0026server_ssl_config_);\n  } else {\n    HttpServerProperties::ForceHTTP11(\u0026proxy_ssl_config_);\n  }\n  ResetConnectionAndRequestForResend();\n  return OK;\n}\n\nvoid HttpNetworkTransaction::HandleClientAuthError(int error) {\n  if (server_ssl_config_.send_client_cert \u0026\u0026\n      (error == ERR_SSL_PROTOCOL_ERROR || IsClientCertificateError(error))) {\n    session_-\u003essl_client_auth_cache()-\u003eRemove(\n        HostPortPair::FromURL(request_-\u003eurl));\n  }\n}\n\n// TODO(rch): This does not correctly handle errors when an SSL proxy is\n// being used, as all of the errors are handled as if they were generated\n// by the endpoint host, request_-\u003eurl, rather than considering if they were\n// generated by the SSL proxy. http://crbug.com/69329\nint HttpNetworkTransaction::HandleSSLHandshakeError(int error) {\n  DCHECK(request_);\n  HandleClientAuthError(error);\n  return error;\n}\n\n// This method determines whether it is safe to resend the request after an\n// IO error.  It can only be called in response to request header or body\n// write errors or response header read errors.  It should not be used in\n// other cases, such as a Connect error.\nint HttpNetworkTransaction::HandleIOError(int error) {\n  // Because the peer may request renegotiation with client authentication at\n  // any time, check and handle client authentication errors.\n  HandleClientAuthError(error);\n\n  switch (error) {\n    // If we try to reuse a connection that the server is in the process of\n    // closing, we may end up successfully writing out our request (or a\n    // portion of our request) only to find a connection error when we try to\n    // read from (or finish writing to) the socket.\n    case ERR_CONNECTION_RESET:\n    case ERR_CONNECTION_CLOSED:\n    case ERR_CONNECTION_ABORTED:\n    // There can be a race between the socket pool checking checking whether a\n    // socket is still connected, receiving the FIN, and sending/reading data\n    // on a reused socket.  If we receive the FIN between the connectedness\n    // check and writing/reading from the socket, we may first learn the socket\n    // is disconnected when we get a ERR_SOCKET_NOT_CONNECTED.  This will most\n    // likely happen when trying to retrieve its IP address.\n    // See http://crbug.com/105824 for more details.\n    case ERR_SOCKET_NOT_CONNECTED:\n    // If a socket is closed on its initial request, HttpStreamParser returns\n    // ERR_EMPTY_RESPONSE. This may still be close/reuse race if the socket was\n    // preconnected but failed to be used before the server timed it out.\n    case ERR_EMPTY_RESPONSE:\n      if (ShouldResendRequest()) {\n        net_log_.AddEventWithNetErrorCode(\n            NetLogEventType::HTTP_TRANSACTION_RESTART_AFTER_ERROR, error);\n        ResetConnectionAndRequestForResend();\n        error = OK;\n      }\n      break;\n    case ERR_SPDY_PING_FAILED:\n    case ERR_SPDY_SERVER_REFUSED_STREAM:\n    case ERR_QUIC_HANDSHAKE_FAILED:\n      net_log_.AddEventWithNetErrorCode(\n          NetLogEventType::HTTP_TRANSACTION_RESTART_AFTER_ERROR, error);\n      ResetConnectionAndRequestForResend();\n      error = OK;\n      break;\n    case ERR_QUIC_PROTOCOL_ERROR:\n      if (GetResponseHeaders() != nullptr ||\n          !stream_-\u003eGetAlternativeService(\u0026retried_alternative_service_)) {\n        // If the response headers have already been recieved and passed up\n        // then the request can not be retried. Also, if there was no\n        // alternative service used for this request, then there is no\n        // alternative service to be disabled.\n        break;\n      }\n      if (session_-\u003ehttp_server_properties()-\u003eIsAlternativeServiceBroken(\n              retried_alternative_service_)) {\n        // If the alternative service was marked as broken while the request\n        // was in flight, retry the request which will not use the broken\n        // alternative service.\n        net_log_.AddEventWithNetErrorCode(\n            NetLogEventType::HTTP_TRANSACTION_RESTART_AFTER_ERROR, error);\n        ResetConnectionAndRequestForResend();\n        error = OK;\n      } else if (session_-\u003eparams().retry_without_alt_svc_on_quic_errors) {\n        // Disable alternative services for this request and retry it. If the\n        // retry succeeds, then the alternative service will be marked as\n        // broken then.\n        enable_alternative_services_ = false;\n        net_log_.AddEventWithNetErrorCode(\n            NetLogEventType::HTTP_TRANSACTION_RESTART_AFTER_ERROR, error);\n        ResetConnectionAndRequestForResend();\n        error = OK;\n      }\n      break;\n  }\n  return error;\n}\n\nvoid HttpNetworkTransaction::ResetStateForRestart() {\n  ResetStateForAuthRestart();\n  if (stream_) {\n    total_received_bytes_ += stream_-\u003eGetTotalReceivedBytes();\n    total_sent_bytes_ += stream_-\u003eGetTotalSentBytes();\n  }\n  CacheNetErrorDetailsAndResetStream();\n}\n\nvoid HttpNetworkTransaction::ResetStateForAuthRestart() {\n  send_start_time_ = base::TimeTicks();\n  send_end_time_ = base::TimeTicks();\n\n  pending_auth_target_ = HttpAuth::AUTH_NONE;\n  read_buf_ = NULL;\n  read_buf_len_ = 0;\n  headers_valid_ = false;\n  request_headers_.Clear();\n  response_ = HttpResponseInfo();\n  establishing_tunnel_ = false;\n  remote_endpoint_ = IPEndPoint();\n  net_error_details_.quic_broken = false;\n  net_error_details_.quic_connection_error = QUIC_NO_ERROR;\n  provided_token_binding_key_.reset();\n  referred_token_binding_key_.reset();\n}\n\nvoid HttpNetworkTransaction::CacheNetErrorDetailsAndResetStream() {\n  if (stream_)\n    stream_-\u003ePopulateNetErrorDetails(\u0026net_error_details_);\n  stream_.reset();\n}\n\nHttpResponseHeaders* HttpNetworkTransaction::GetResponseHeaders() const {\n  return response_.headers.get();\n}\n\nbool HttpNetworkTransaction::ShouldResendRequest() const {\n  bool connection_is_proven = stream_-\u003eIsConnectionReused();\n  bool has_received_headers = GetResponseHeaders() != NULL;\n\n  // NOTE: we resend a request only if we reused a keep-alive connection.\n  // This automatically prevents an infinite resend loop because we'll run\n  // out of the cached keep-alive connections eventually.\n  if (connection_is_proven \u0026\u0026 !has_received_headers)\n    return true;\n  return false;\n}\n\nvoid HttpNetworkTransaction::ResetConnectionAndRequestForResend() {\n  if (stream_.get()) {\n    stream_-\u003eClose(true);\n    CacheNetErrorDetailsAndResetStream();\n  }\n\n  // We need to clear request_headers_ because it contains the real request\n  // headers, but we may need to resend the CONNECT request first to recreate\n  // the SSL tunnel.\n  request_headers_.Clear();\n  next_state_ = STATE_CREATE_STREAM;  // Resend the request.\n}\n\nbool HttpNetworkTransaction::ShouldApplyProxyAuth() const {\n  return UsingHttpProxyWithoutTunnel();\n}\n\nbool HttpNetworkTransaction::ShouldApplyServerAuth() const {\n  return !(request_-\u003eload_flags \u0026 LOAD_DO_NOT_SEND_AUTH_DATA);\n}\n\nint HttpNetworkTransaction::HandleAuthChallenge() {\n  scoped_refptr\u003cHttpResponseHeaders\u003e headers(GetResponseHeaders());\n  DCHECK(headers.get());\n\n  int status = headers-\u003eresponse_code();\n  if (status != HTTP_UNAUTHORIZED \u0026\u0026\n      status != HTTP_PROXY_AUTHENTICATION_REQUIRED)\n    return OK;\n  HttpAuth::Target target = status == HTTP_PROXY_AUTHENTICATION_REQUIRED ?\n                            HttpAuth::AUTH_PROXY : HttpAuth::AUTH_SERVER;\n  if (target == HttpAuth::AUTH_PROXY \u0026\u0026 proxy_info_.is_direct())\n    return ERR_UNEXPECTED_PROXY_AUTH;\n\n  // This case can trigger when an HTTPS server responds with a \"Proxy\n  // authentication required\" status code through a non-authenticating\n  // proxy.\n  if (!auth_controllers_[target].get())\n    return ERR_UNEXPECTED_PROXY_AUTH;\n\n  int rv = auth_controllers_[target]-\u003eHandleAuthChallenge(\n      headers, response_.ssl_info,\n      (request_-\u003eload_flags \u0026 LOAD_DO_NOT_SEND_AUTH_DATA) != 0, false,\n      net_log_);\n  if (auth_controllers_[target]-\u003eHaveAuthHandler())\n    pending_auth_target_ = target;\n\n  scoped_refptr\u003cAuthChallengeInfo\u003e auth_info =\n      auth_controllers_[target]-\u003eauth_info();\n  if (auth_info.get())\n      response_.auth_challenge = auth_info;\n\n  return rv;\n}\n\nbool HttpNetworkTransaction::HaveAuth(HttpAuth::Target target) const {\n  return auth_controllers_[target].get() \u0026\u0026\n      auth_controllers_[target]-\u003eHaveAuth();\n}\n\nGURL HttpNetworkTransaction::AuthURL(HttpAuth::Target target) const {\n  switch (target) {\n    case HttpAuth::AUTH_PROXY: {\n      if (!proxy_info_.proxy_server().is_valid() ||\n          proxy_info_.proxy_server().is_direct()) {\n        return GURL();  // There is no proxy server.\n      }\n      const char* scheme = proxy_info_.is_https() ? \"https://\" : \"http://\";\n      return GURL(scheme +\n                  proxy_info_.proxy_server().host_port_pair().ToString());\n    }\n    case HttpAuth::AUTH_SERVER:\n      if (ForWebSocketHandshake()) {\n        const GURL\u0026 url = request_-\u003eurl;\n        url::Replacements\u003cchar\u003e ws_to_http;\n        if (url.SchemeIs(\"ws\")) {\n          ws_to_http.SetScheme(\"http\", url::Component(0, 4));\n        } else {\n          DCHECK(url.SchemeIs(\"wss\"));\n          ws_to_http.SetScheme(\"https\", url::Component(0, 5));\n        }\n        return url.ReplaceComponents(ws_to_http);\n      }\n      return request_-\u003eurl;\n    default:\n     return GURL();\n  }\n}\n\nbool HttpNetworkTransaction::ForWebSocketHandshake() const {\n  return websocket_handshake_stream_base_create_helper_ \u0026\u0026\n         request_-\u003eurl.SchemeIsWSOrWSS();\n}\n\nvoid HttpNetworkTransaction::CopyConnectionAttemptsFromStreamRequest() {\n  DCHECK(stream_request_);\n\n  // Since the transaction can restart with auth credentials, it may create a\n  // stream more than once. Accumulate all of the connection attempts across\n  // those streams by appending them to the vector:\n  for (const auto\u0026 attempt : stream_request_-\u003econnection_attempts())\n    connection_attempts_.push_back(attempt);\n}\n\nbool HttpNetworkTransaction::ContentEncodingsValid() const {\n  HttpResponseHeaders* headers = GetResponseHeaders();\n  DCHECK(headers);\n\n  std::string accept_encoding;\n  request_headers_.GetHeader(HttpRequestHeaders::kAcceptEncoding,\n                             \u0026accept_encoding);\n  std::set\u003cstd::string\u003e allowed_encodings;\n  if (!HttpUtil::ParseAcceptEncoding(accept_encoding, \u0026allowed_encodings)) {\n    FilterSourceStream::ReportContentDecodingFailed(SourceStream::TYPE_INVALID);\n    return false;\n  }\n\n  std::string content_encoding;\n  headers-\u003eGetNormalizedHeader(\"Content-Encoding\", \u0026content_encoding);\n  std::set\u003cstd::string\u003e used_encodings;\n  if (!HttpUtil::ParseContentEncoding(content_encoding, \u0026used_encodings)) {\n    FilterSourceStream::ReportContentDecodingFailed(SourceStream::TYPE_INVALID);\n    return false;\n  }\n\n  // When \"Accept-Encoding\" is not specified, it is parsed as \"*\".\n  // If \"*\" encoding is advertised, then any encoding should be \"accepted\".\n  // This does not mean, that it will be successfully decoded.\n  if (allowed_encodings.find(\"*\") != allowed_encodings.end())\n    return true;\n\n  bool result = true;\n  for (auto const\u0026 encoding : used_encodings) {\n    SourceStream::SourceType source_type =\n        FilterSourceStream::ParseEncodingType(encoding);\n    // We don't reject encodings we are not aware. They just will not decode.\n    if (source_type == SourceStream::TYPE_UNKNOWN)\n      continue;\n    if (allowed_encodings.find(encoding) == allowed_encodings.end()) {\n      FilterSourceStream::ReportContentDecodingFailed(\n          SourceStream::TYPE_REJECTED);\n      result = false;\n      break;\n    }\n  }\n\n  // Temporary workaround for http://crbug.com/714514\n  if (headers-\u003eIsRedirect(nullptr)) {\n    UMA_HISTOGRAM_BOOLEAN(\"Net.RedirectWithUnadvertisedContentEncoding\",\n                          !result);\n    return true;\n  }\n\n  return result;\n}\n\n}  // namespace net\n"},"gob_info":{"repo":"chromium/chromium/src","commit":"c59068590b02e4c25544b62a5a9a5cf6863252b3","path":"net/http/http_network_transaction.cc"}}}],"elapsed_ms":11}