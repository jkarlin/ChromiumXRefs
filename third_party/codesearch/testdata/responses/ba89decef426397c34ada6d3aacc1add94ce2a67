{"file_info_response":[{"return_code":1,"file_info":{"name":"src/base/files/file.h","lines":"381","size":"14664","language":"c++","type":1,"md5":"88208cb7c7c06966917acb87831ab046","changelist_num":"5d546d806f9753d54593be07a4aa014a2ab875d3","mime_type":"text/plain","generated":false,"package_name":"chromium","content":{"text":"// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef BASE_FILES_FILE_H_\n#define BASE_FILES_FILE_H_\n\n#include \u003cstdint.h\u003e\n\n#include \u003cstring\u003e\n\n#include \"base/base_export.h\"\n#include \"base/files/file_path.h\"\n#include \"base/files/file_tracing.h\"\n#include \"base/files/scoped_file.h\"\n#include \"base/macros.h\"\n#include \"base/time/time.h\"\n#include \"build/build_config.h\"\n\n#if defined(OS_WIN)\n#include \u003cwindows.h\u003e\n#include \"base/win/scoped_handle.h\"\n#endif\n\n#if defined(OS_POSIX)\n#include \u003csys/stat.h\u003e\n#endif\n\nnamespace base {\n\n#if defined(OS_WIN)\nusing PlatformFile = HANDLE;\n\nconst PlatformFile kInvalidPlatformFile = INVALID_HANDLE_VALUE;\n#elif defined(OS_POSIX)\nusing PlatformFile = int;\n\nconst PlatformFile kInvalidPlatformFile = -1;\n#if defined(OS_BSD) || defined(OS_MACOSX) || defined(OS_NACL)\ntypedef struct stat stat_wrapper_t;\n#else\ntypedef struct stat64 stat_wrapper_t;\n#endif\n#endif  // defined(OS_POSIX)\n\n// Thin wrapper around an OS-level file.\n// Note that this class does not provide any support for asynchronous IO, other\n// than the ability to create asynchronous handles on Windows.\n//\n// Note about const: this class does not attempt to determine if the underlying\n// file system object is affected by a particular method in order to consider\n// that method const or not. Only methods that deal with member variables in an\n// obvious non-modifying way are marked as const. Any method that forward calls\n// to the OS is not considered const, even if there is no apparent change to\n// member variables.\nclass BASE_EXPORT File {\n public:\n  // FLAG_(OPEN|CREATE).* are mutually exclusive. You should specify exactly one\n  // of the five (possibly combining with other flags) when opening or creating\n  // a file.\n  // FLAG_(WRITE|APPEND) are mutually exclusive. This is so that APPEND behavior\n  // will be consistent with O_APPEND on POSIX.\n  // FLAG_EXCLUSIVE_(READ|WRITE) only grant exclusive access to the file on\n  // creation on POSIX; for existing files, consider using Lock().\n  enum Flags {\n    FLAG_OPEN = 1 \u003c\u003c 0,            // Opens a file, only if it exists.\n    FLAG_CREATE = 1 \u003c\u003c 1,          // Creates a new file, only if it does not\n                                   // already exist.\n    FLAG_OPEN_ALWAYS = 1 \u003c\u003c 2,     // May create a new file.\n    FLAG_CREATE_ALWAYS = 1 \u003c\u003c 3,   // May overwrite an old file.\n    FLAG_OPEN_TRUNCATED = 1 \u003c\u003c 4,  // Opens a file and truncates it, only if it\n                                   // exists.\n    FLAG_READ = 1 \u003c\u003c 5,\n    FLAG_WRITE = 1 \u003c\u003c 6,\n    FLAG_APPEND = 1 \u003c\u003c 7,\n    FLAG_EXCLUSIVE_READ = 1 \u003c\u003c 8,  // EXCLUSIVE is opposite of Windows SHARE.\n    FLAG_EXCLUSIVE_WRITE = 1 \u003c\u003c 9,\n    FLAG_ASYNC = 1 \u003c\u003c 10,\n    FLAG_TEMPORARY = 1 \u003c\u003c 11,  // Used on Windows only.\n    FLAG_HIDDEN = 1 \u003c\u003c 12,     // Used on Windows only.\n    FLAG_DELETE_ON_CLOSE = 1 \u003c\u003c 13,\n    FLAG_WRITE_ATTRIBUTES = 1 \u003c\u003c 14,     // Used on Windows only.\n    FLAG_SHARE_DELETE = 1 \u003c\u003c 15,         // Used on Windows only.\n    FLAG_TERMINAL_DEVICE = 1 \u003c\u003c 16,      // Serial port flags.\n    FLAG_BACKUP_SEMANTICS = 1 \u003c\u003c 17,     // Used on Windows only.\n    FLAG_EXECUTE = 1 \u003c\u003c 18,              // Used on Windows only.\n    FLAG_SEQUENTIAL_SCAN = 1 \u003c\u003c 19,      // Used on Windows only.\n    FLAG_CAN_DELETE_ON_CLOSE = 1 \u003c\u003c 20,  // Requests permission to delete a file\n                                         // via DeleteOnClose() (Windows only).\n                                         // See DeleteOnClose() for details.\n  };\n\n  // This enum has been recorded in multiple histograms. If the order of the\n  // fields needs to change, please ensure that those histograms are obsolete or\n  // have been moved to a different enum.\n  //\n  // FILE_ERROR_ACCESS_DENIED is returned when a call fails because of a\n  // filesystem restriction. FILE_ERROR_SECURITY is returned when a browser\n  // policy doesn't allow the operation to be executed.\n  enum Error {\n    FILE_OK = 0,\n    FILE_ERROR_FAILED = -1,\n    FILE_ERROR_IN_USE = -2,\n    FILE_ERROR_EXISTS = -3,\n    FILE_ERROR_NOT_FOUND = -4,\n    FILE_ERROR_ACCESS_DENIED = -5,\n    FILE_ERROR_TOO_MANY_OPENED = -6,\n    FILE_ERROR_NO_MEMORY = -7,\n    FILE_ERROR_NO_SPACE = -8,\n    FILE_ERROR_NOT_A_DIRECTORY = -9,\n    FILE_ERROR_INVALID_OPERATION = -10,\n    FILE_ERROR_SECURITY = -11,\n    FILE_ERROR_ABORT = -12,\n    FILE_ERROR_NOT_A_FILE = -13,\n    FILE_ERROR_NOT_EMPTY = -14,\n    FILE_ERROR_INVALID_URL = -15,\n    FILE_ERROR_IO = -16,\n    // Put new entries here and increment FILE_ERROR_MAX.\n    FILE_ERROR_MAX = -17\n  };\n\n  // This explicit mapping matches both FILE_ on Windows and SEEK_ on Linux.\n  enum Whence {\n    FROM_BEGIN   = 0,\n    FROM_CURRENT = 1,\n    FROM_END     = 2\n  };\n\n  // Used to hold information about a given file.\n  // If you add more fields to this structure (platform-specific fields are OK),\n  // make sure to update all functions that use it in file_util_{win|posix}.cc,\n  // too, and the ParamTraits\u003cbase::File::Info\u003e implementation in\n  // ipc/ipc_message_utils.cc.\n  struct BASE_EXPORT Info {\n    Info();\n    ~Info();\n#if defined(OS_POSIX)\n    // Fills this struct with values from |stat_info|.\n    void FromStat(const stat_wrapper_t\u0026 stat_info);\n#endif\n\n    // The size of the file in bytes.  Undefined when is_directory is true.\n    int64_t size;\n\n    // True if the file corresponds to a directory.\n    bool is_directory;\n\n    // True if the file corresponds to a symbolic link.  For Windows currently\n    // not supported and thus always false.\n    bool is_symbolic_link;\n\n    // The last modified time of a file.\n    Time last_modified;\n\n    // The last accessed time of a file.\n    Time last_accessed;\n\n    // The creation time of a file.\n    Time creation_time;\n  };\n\n  File();\n\n  // Creates or opens the given file. This will fail with 'access denied' if the\n  // |path| contains path traversal ('..') components.\n  File(const FilePath\u0026 path, uint32_t flags);\n\n  // Takes ownership of |platform_file|.\n  explicit File(PlatformFile platform_file);\n\n  // Creates an object with a specific error_details code.\n  explicit File(Error error_details);\n\n  File(File\u0026\u0026 other);\n\n  ~File();\n\n  // Takes ownership of |platform_file|.\n  static File CreateForAsyncHandle(PlatformFile platform_file);\n\n  File\u0026 operator=(File\u0026\u0026 other);\n\n  // Creates or opens the given file.\n  void Initialize(const FilePath\u0026 path, uint32_t flags);\n\n  // Returns |true| if the handle / fd wrapped by this object is valid.  This\n  // method doesn't interact with the file system (and is safe to be called from\n  // ThreadRestrictions::SetIOAllowed(false) threads).\n  bool IsValid() const;\n\n  // Returns true if a new file was created (or an old one truncated to zero\n  // length to simulate a new file, which can happen with\n  // FLAG_CREATE_ALWAYS), and false otherwise.\n  bool created() const { return created_; }\n\n  // Returns the OS result of opening this file. Note that the way to verify\n  // the success of the operation is to use IsValid(), not this method:\n  //   File file(path, flags);\n  //   if (!file.IsValid())\n  //     return;\n  Error error_details() const { return error_details_; }\n\n  PlatformFile GetPlatformFile() const;\n  PlatformFile TakePlatformFile();\n\n  // Destroying this object closes the file automatically.\n  void Close();\n\n  // Changes current position in the file to an |offset| relative to an origin\n  // defined by |whence|. Returns the resultant current position in the file\n  // (relative to the start) or -1 in case of error.\n  int64_t Seek(Whence whence, int64_t offset);\n\n  // Reads the given number of bytes (or until EOF is reached) starting with the\n  // given offset. Returns the number of bytes read, or -1 on error. Note that\n  // this function makes a best effort to read all data on all platforms, so it\n  // is not intended for stream oriented files but instead for cases when the\n  // normal expectation is that actually |size| bytes are read unless there is\n  // an error.\n  int Read(int64_t offset, char* data, int size);\n\n  // Same as above but without seek.\n  int ReadAtCurrentPos(char* data, int size);\n\n  // Reads the given number of bytes (or until EOF is reached) starting with the\n  // given offset, but does not make any effort to read all data on all\n  // platforms. Returns the number of bytes read, or -1 on error.\n  int ReadNoBestEffort(int64_t offset, char* data, int size);\n\n  // Same as above but without seek.\n  int ReadAtCurrentPosNoBestEffort(char* data, int size);\n\n  // Writes the given buffer into the file at the given offset, overwritting any\n  // data that was previously there. Returns the number of bytes written, or -1\n  // on error. Note that this function makes a best effort to write all data on\n  // all platforms.\n  // Ignores the offset and writes to the end of the file if the file was opened\n  // with FLAG_APPEND.\n  int Write(int64_t offset, const char* data, int size);\n\n  // Save as above but without seek.\n  int WriteAtCurrentPos(const char* data, int size);\n\n  // Save as above but does not make any effort to write all data on all\n  // platforms. Returns the number of bytes written, or -1 on error.\n  int WriteAtCurrentPosNoBestEffort(const char* data, int size);\n\n  // Returns the current size of this file, or a negative number on failure.\n  int64_t GetLength();\n\n  // Truncates the file to the given length. If |length| is greater than the\n  // current size of the file, the file is extended with zeros. If the file\n  // doesn't exist, |false| is returned.\n  bool SetLength(int64_t length);\n\n  // Instructs the filesystem to flush the file to disk. (POSIX: fsync, Windows:\n  // FlushFileBuffers).\n  // Calling Flush() does not guarantee file integrity and thus is not a valid\n  // substitute for file integrity checks and recovery codepaths for malformed\n  // files. It can also be *really* slow, so avoid blocking on Flush(),\n  // especially please don't block shutdown on Flush().\n  // Latency percentiles of Flush() across all platforms as of July 2016:\n  // 50 %     \u003e 5 ms\n  // 10 %     \u003e 58 ms\n  //  1 %     \u003e 357 ms\n  //  0.1 %   \u003e 1.8 seconds\n  //  0.01 %  \u003e 7.6 seconds\n  bool Flush();\n\n  // Updates the file times.\n  bool SetTimes(Time last_access_time, Time last_modified_time);\n\n  // Returns some basic information for the given file.\n  bool GetInfo(Info* info);\n\n  // Attempts to take an exclusive write lock on the file. Returns immediately\n  // (i.e. does not wait for another process to unlock the file). If the lock\n  // was obtained, the result will be FILE_OK. A lock only guarantees\n  // that other processes may not also take a lock on the same file with the\n  // same API - it may still be opened, renamed, unlinked, etc.\n  //\n  // Common semantics:\n  //  * Locks are held by processes, but not inherited by child processes.\n  //  * Locks are released by the OS on file close or process termination.\n  //  * Locks are reliable only on local filesystems.\n  //  * Duplicated file handles may also write to locked files.\n  // Windows-specific semantics:\n  //  * Locks are mandatory for read/write APIs, advisory for mapping APIs.\n  //  * Within a process, locking the same file (by the same or new handle)\n  //    will fail.\n  // POSIX-specific semantics:\n  //  * Locks are advisory only.\n  //  * Within a process, locking the same file (by the same or new handle)\n  //    will succeed.\n  //  * Closing any descriptor on a given file releases the lock.\n  Error Lock();\n\n  // Unlock a file previously locked.\n  Error Unlock();\n\n  // Returns a new object referencing this file for use within the current\n  // process. Handling of FLAG_DELETE_ON_CLOSE varies by OS. On POSIX, the File\n  // object that was created or initialized with this flag will have unlinked\n  // the underlying file when it was created or opened. On Windows, the\n  // underlying file is deleted when the last handle to it is closed.\n  File Duplicate() const;\n\n  bool async() const { return async_; }\n\n#if defined(OS_WIN)\n  // Sets or clears the DeleteFile disposition on the handle. Returns true if\n  // the disposition was set or cleared, as indicated by |delete_on_close|.\n  //\n  // Microsoft Windows deletes a file only when the last handle to the\n  // underlying kernel object is closed when the DeleteFile disposition has been\n  // set by any handle holder. This disposition is be set by:\n  // - Calling the Win32 DeleteFile function with the path to a file.\n  // - Opening/creating a file with FLAG_DELETE_ON_CLOSE.\n  // - Opening/creating a file with FLAG_CAN_DELETE_ON_CLOSE and subsequently\n  //   calling DeleteOnClose(true).\n  //\n  // In all cases, all pre-existing handles to the file must have been opened\n  // with FLAG_SHARE_DELETE.\n  //\n  // So:\n  // - Use FLAG_SHARE_DELETE when creating/opening a file to allow another\n  //   entity on the system to cause it to be deleted when it is closed. (Note:\n  //   another entity can delete the file the moment after it is closed, so not\n  //   using this permission doesn't provide any protections.)\n  // - Use FLAG_DELETE_ON_CLOSE for any file that is to be deleted after use.\n  //   The OS will ensure it is deleted even in the face of process termination.\n  // - Use FLAG_CAN_DELETE_ON_CLOSE in conjunction with DeleteOnClose() to alter\n  //   the DeleteFile disposition on an open handle. This fine-grained control\n  //   allows for marking a file for deletion during processing so that it is\n  //   deleted in the event of untimely process termination, and then clearing\n  //   this state once the file is suitable for persistence.\n  bool DeleteOnClose(bool delete_on_close);\n#endif\n\n#if defined(OS_WIN)\n  static Error OSErrorToFileError(DWORD last_error);\n#elif defined(OS_POSIX)\n  static Error OSErrorToFileError(int saved_errno);\n#endif\n\n  // Converts an error value to a human-readable form. Used for logging.\n  static std::string ErrorToString(Error error);\n\n private:\n  friend class FileTracing::ScopedTrace;\n\n  // Creates or opens the given file. Only called if |path| has no\n  // traversal ('..') components.\n  void DoInitialize(const FilePath\u0026 path, uint32_t flags);\n\n  void SetPlatformFile(PlatformFile file);\n\n#if defined(OS_WIN)\n  win::ScopedHandle file_;\n#elif defined(OS_POSIX)\n  ScopedFD file_;\n#endif\n\n  // A path to use for tracing purposes. Set if file tracing is enabled during\n  // |Initialize()|.\n  FilePath tracing_path_;\n\n  // Object tied to the lifetime of |this| that enables/disables tracing.\n  FileTracing::ScopedEnabler trace_enabler_;\n\n  Error error_details_;\n  bool created_;\n  bool async_;\n\n  DISALLOW_COPY_AND_ASSIGN(File);\n};\n\n}  // namespace base\n\n#endif  // BASE_FILES_FILE_H_\n\n"},"gob_info":{"repo":"chromium/chromium/src","commit":"5d546d806f9753d54593be07a4aa014a2ab875d3","path":"base/files/file.h"}}}],"elapsed_ms":44}