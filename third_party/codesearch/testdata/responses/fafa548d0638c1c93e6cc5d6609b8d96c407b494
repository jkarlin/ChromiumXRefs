{"file_info_response":[{"return_code":1,"file_info":{"name":"src/base/pickle.h","lines":"385","size":"15272","language":"c++","type":1,"md5":"ea6f0d340bfcca8d257ef61bc8cb90f6","changelist_num":"65dcbb2ab5805377de065aaa1dbc87215df460f7","mime_type":"text/plain","generated":false,"package_name":"chromium","content":{"text":"// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef BASE_PICKLE_H_\n#define BASE_PICKLE_H_\n\n#include \u003cstddef.h\u003e\n#include \u003cstdint.h\u003e\n\n#include \u003cstring\u003e\n\n#include \"base/base_export.h\"\n#include \"base/compiler_specific.h\"\n#include \"base/gtest_prod_util.h\"\n#include \"base/logging.h\"\n#include \"base/memory/ref_counted.h\"\n#include \"base/strings/string16.h\"\n#include \"base/strings/string_piece.h\"\n\n#if defined(OS_POSIX)\n#include \"base/files/file.h\"\n#endif\n\nnamespace base {\n\nclass Pickle;\n\n// PickleIterator reads data from a Pickle. The Pickle object must remain valid\n// while the PickleIterator object is in use.\nclass BASE_EXPORT PickleIterator {\n public:\n  PickleIterator() : payload_(NULL), read_index_(0), end_index_(0) {}\n  explicit PickleIterator(const Pickle\u0026 pickle);\n\n  // Methods for reading the payload of the Pickle. To read from the start of\n  // the Pickle, create a PickleIterator from a Pickle. If successful, these\n  // methods return true. Otherwise, false is returned to indicate that the\n  // result could not be extracted. It is not possible to read from the iterator\n  // after that.\n  bool ReadBool(bool* result) WARN_UNUSED_RESULT;\n  bool ReadInt(int* result) WARN_UNUSED_RESULT;\n  bool ReadLong(long* result) WARN_UNUSED_RESULT;\n  bool ReadUInt16(uint16_t* result) WARN_UNUSED_RESULT;\n  bool ReadUInt32(uint32_t* result) WARN_UNUSED_RESULT;\n  bool ReadInt64(int64_t* result) WARN_UNUSED_RESULT;\n  bool ReadUInt64(uint64_t* result) WARN_UNUSED_RESULT;\n  bool ReadFloat(float* result) WARN_UNUSED_RESULT;\n  bool ReadDouble(double* result) WARN_UNUSED_RESULT;\n  bool ReadString(std::string* result) WARN_UNUSED_RESULT;\n  // The StringPiece data will only be valid for the lifetime of the message.\n  bool ReadStringPiece(StringPiece* result) WARN_UNUSED_RESULT;\n  bool ReadString16(string16* result) WARN_UNUSED_RESULT;\n  // The StringPiece16 data will only be valid for the lifetime of the message.\n  bool ReadStringPiece16(StringPiece16* result) WARN_UNUSED_RESULT;\n\n  // A pointer to the data will be placed in |*data|, and the length will be\n  // placed in |*length|. The pointer placed into |*data| points into the\n  // message's buffer so it will be scoped to the lifetime of the message (or\n  // until the message data is mutated). Do not keep the pointer around!\n  bool ReadData(const char** data, int* length) WARN_UNUSED_RESULT;\n\n  // A pointer to the data will be placed in |*data|. The caller specifies the\n  // number of bytes to read, and ReadBytes will validate this length. The\n  // pointer placed into |*data| points into the message's buffer so it will be\n  // scoped to the lifetime of the message (or until the message data is\n  // mutated). Do not keep the pointer around!\n  bool ReadBytes(const char** data, int length) WARN_UNUSED_RESULT;\n\n  // A safer version of ReadInt() that checks for the result not being negative.\n  // Use it for reading the object sizes.\n  bool ReadLength(int* result) WARN_UNUSED_RESULT {\n    return ReadInt(result) \u0026\u0026 *result \u003e= 0;\n  }\n\n  // Skips bytes in the read buffer and returns true if there are at least\n  // num_bytes available. Otherwise, does nothing and returns false.\n  bool SkipBytes(int num_bytes) WARN_UNUSED_RESULT {\n    return !!GetReadPointerAndAdvance(num_bytes);\n  }\n\n private:\n  // Read Type from Pickle.\n  template \u003ctypename Type\u003e\n  bool ReadBuiltinType(Type* result);\n\n  // Advance read_index_ but do not allow it to exceed end_index_.\n  // Keeps read_index_ aligned.\n  void Advance(size_t size);\n\n  // Get read pointer for Type and advance read pointer.\n  template\u003ctypename Type\u003e\n  const char* GetReadPointerAndAdvance();\n\n  // Get read pointer for |num_bytes| and advance read pointer. This method\n  // checks num_bytes for negativity and wrapping.\n  const char* GetReadPointerAndAdvance(int num_bytes);\n\n  // Get read pointer for (num_elements * size_element) bytes and advance read\n  // pointer. This method checks for int overflow, negativity and wrapping.\n  const char* GetReadPointerAndAdvance(int num_elements,\n                                       size_t size_element);\n\n  const char* payload_;  // Start of our pickle's payload.\n  size_t read_index_;  // Offset of the next readable byte in payload.\n  size_t end_index_;  // Payload size.\n\n  FRIEND_TEST_ALL_PREFIXES(PickleTest, GetReadPointerAndAdvance);\n};\n\n// This class provides an interface analogous to base::Pickle's WriteFoo()\n// methods and can be used to accurately compute the size of a hypothetical\n// Pickle's payload without having to reference the Pickle implementation.\nclass BASE_EXPORT PickleSizer {\n public:\n  PickleSizer();\n  ~PickleSizer();\n\n  // Returns the computed size of the payload.\n  size_t payload_size() const { return payload_size_; }\n\n  void AddBool() { return AddInt(); }\n  void AddInt() { AddPOD\u003cint\u003e(); }\n  void AddLong() { AddPOD\u003cuint64_t\u003e(); }\n  void AddUInt16() { return AddPOD\u003cuint16_t\u003e(); }\n  void AddUInt32() { return AddPOD\u003cuint32_t\u003e(); }\n  void AddInt64() { return AddPOD\u003cint64_t\u003e(); }\n  void AddUInt64() { return AddPOD\u003cuint64_t\u003e(); }\n  void AddFloat() { return AddPOD\u003cfloat\u003e(); }\n  void AddDouble() { return AddPOD\u003cdouble\u003e(); }\n  void AddString(const StringPiece\u0026 value);\n  void AddString16(const StringPiece16\u0026 value);\n  void AddData(int length);\n  void AddBytes(int length);\n  void AddAttachment();\n\n private:\n  // Just like AddBytes() but with a compile-time size for performance.\n  template\u003csize_t length\u003e void BASE_EXPORT AddBytesStatic();\n\n  template \u003ctypename T\u003e\n  void AddPOD() { AddBytesStatic\u003csizeof(T)\u003e(); }\n\n  size_t payload_size_ = 0;\n};\n\n// This class provides facilities for basic binary value packing and unpacking.\n//\n// The Pickle class supports appending primitive values (ints, strings, etc.)\n// to a pickle instance.  The Pickle instance grows its internal memory buffer\n// dynamically to hold the sequence of primitive values.   The internal memory\n// buffer is exposed as the \"data\" of the Pickle.  This \"data\" can be passed\n// to a Pickle object to initialize it for reading.\n//\n// When reading from a Pickle object, it is important for the consumer to know\n// what value types to read and in what order to read them as the Pickle does\n// not keep track of the type of data written to it.\n//\n// The Pickle's data has a header which contains the size of the Pickle's\n// payload.  It can optionally support additional space in the header.  That\n// space is controlled by the header_size parameter passed to the Pickle\n// constructor.\n//\nclass BASE_EXPORT Pickle {\n public:\n  // Auxiliary data attached to a Pickle. Pickle must be subclassed along with\n  // this interface in order to provide a concrete implementation of support\n  // for attachments. The base Pickle implementation does not accept\n  // attachments.\n  class BASE_EXPORT Attachment : public RefCountedThreadSafe\u003cAttachment\u003e {\n   public:\n    Attachment();\n\n   protected:\n    friend class RefCountedThreadSafe\u003cAttachment\u003e;\n    virtual ~Attachment();\n\n    DISALLOW_COPY_AND_ASSIGN(Attachment);\n  };\n\n  // Initialize a Pickle object using the default header size.\n  Pickle();\n\n  // Initialize a Pickle object with the specified header size in bytes, which\n  // must be greater-than-or-equal-to sizeof(Pickle::Header).  The header size\n  // will be rounded up to ensure that the header size is 32bit-aligned.\n  explicit Pickle(int header_size);\n\n  // Initializes a Pickle from a const block of data.  The data is not copied;\n  // instead the data is merely referenced by this Pickle.  Only const methods\n  // should be used on the Pickle when initialized this way.  The header\n  // padding size is deduced from the data length.\n  Pickle(const char* data, int data_len);\n\n  // Initializes a Pickle as a deep copy of another Pickle.\n  Pickle(const Pickle\u0026 other);\n\n  // Note: There are no virtual methods in this class.  This destructor is\n  // virtual as an element of defensive coding.  Other classes have derived from\n  // this class, and there is a *chance* that they will cast into this base\n  // class before destruction.  At least one such class does have a virtual\n  // destructor, suggesting at least some need to call more derived destructors.\n  virtual ~Pickle();\n\n  // Performs a deep copy.\n  Pickle\u0026 operator=(const Pickle\u0026 other);\n\n  // Returns the number of bytes written in the Pickle, including the header.\n  size_t size() const { return header_size_ + header_-\u003epayload_size; }\n\n  // Returns the data for this Pickle.\n  const void* data() const { return header_; }\n\n  // Returns the effective memory capacity of this Pickle, that is, the total\n  // number of bytes currently dynamically allocated or 0 in the case of a\n  // read-only Pickle. This should be used only for diagnostic / profiling\n  // purposes.\n  size_t GetTotalAllocatedSize() const;\n\n  // Methods for adding to the payload of the Pickle.  These values are\n  // appended to the end of the Pickle's payload.  When reading values from a\n  // Pickle, it is important to read them in the order in which they were added\n  // to the Pickle.\n\n  bool WriteBool(bool value) {\n    return WriteInt(value ? 1 : 0);\n  }\n  bool WriteInt(int value) {\n    return WritePOD(value);\n  }\n  bool WriteLong(long value) {\n    // Always write long as a 64-bit value to ensure compatibility between\n    // 32-bit and 64-bit processes.\n    return WritePOD(static_cast\u003cint64_t\u003e(value));\n  }\n  bool WriteUInt16(uint16_t value) { return WritePOD(value); }\n  bool WriteUInt32(uint32_t value) { return WritePOD(value); }\n  bool WriteInt64(int64_t value) { return WritePOD(value); }\n  bool WriteUInt64(uint64_t value) { return WritePOD(value); }\n  bool WriteFloat(float value) {\n    return WritePOD(value);\n  }\n  bool WriteDouble(double value) {\n    return WritePOD(value);\n  }\n  bool WriteString(const StringPiece\u0026 value);\n  bool WriteString16(const StringPiece16\u0026 value);\n  // \"Data\" is a blob with a length. When you read it out you will be given the\n  // length. See also WriteBytes.\n  bool WriteData(const char* data, int length);\n  // \"Bytes\" is a blob with no length. The caller must specify the length both\n  // when reading and writing. It is normally used to serialize PoD types of a\n  // known size. See also WriteData.\n  bool WriteBytes(const void* data, int length);\n\n  // WriteAttachment appends |attachment| to the pickle. It returns\n  // false iff the set is full or if the Pickle implementation does not support\n  // attachments.\n  virtual bool WriteAttachment(scoped_refptr\u003cAttachment\u003e attachment);\n\n  // ReadAttachment parses an attachment given the parsing state |iter| and\n  // writes it to |*attachment|. It returns true on success.\n  virtual bool ReadAttachment(base::PickleIterator* iter,\n                              scoped_refptr\u003cAttachment\u003e* attachment) const;\n\n  // Indicates whether the pickle has any attachments.\n  virtual bool HasAttachments() const;\n\n  // Reserves space for upcoming writes when multiple writes will be made and\n  // their sizes are computed in advance. It can be significantly faster to call\n  // Reserve() before calling WriteFoo() multiple times.\n  void Reserve(size_t additional_capacity);\n\n  // Payload follows after allocation of Header (header size is customizable).\n  struct Header {\n    uint32_t payload_size;  // Specifies the size of the payload.\n  };\n\n  // Returns the header, cast to a user-specified type T.  The type T must be a\n  // subclass of Header and its size must correspond to the header_size passed\n  // to the Pickle constructor.\n  template \u003cclass T\u003e\n  T* headerT() {\n    DCHECK_EQ(header_size_, sizeof(T));\n    return static_cast\u003cT*\u003e(header_);\n  }\n  template \u003cclass T\u003e\n  const T* headerT() const {\n    DCHECK_EQ(header_size_, sizeof(T));\n    return static_cast\u003cconst T*\u003e(header_);\n  }\n\n  // The payload is the pickle data immediately following the header.\n  size_t payload_size() const {\n    return header_ ? header_-\u003epayload_size : 0;\n  }\n\n  const char* payload() const {\n    return reinterpret_cast\u003cconst char*\u003e(header_) + header_size_;\n  }\n\n  // Returns the address of the byte immediately following the currently valid\n  // header + payload.\n  const char* end_of_payload() const {\n    // This object may be invalid.\n    return header_ ? payload() + payload_size() : NULL;\n  }\n\n protected:\n  char* mutable_payload() {\n    return reinterpret_cast\u003cchar*\u003e(header_) + header_size_;\n  }\n\n  size_t capacity_after_header() const {\n    return capacity_after_header_;\n  }\n\n  // Resize the capacity, note that the input value should not include the size\n  // of the header.\n  void Resize(size_t new_capacity);\n\n  // Claims |num_bytes| bytes of payload. This is similar to Reserve() in that\n  // it may grow the capacity, but it also advances the write offset of the\n  // pickle by |num_bytes|. Claimed memory, including padding, is zeroed.\n  //\n  // Returns the address of the first byte claimed.\n  void* ClaimBytes(size_t num_bytes);\n\n  // Find the end of the pickled data that starts at range_start.  Returns NULL\n  // if the entire Pickle is not found in the given data range.\n  static const char* FindNext(size_t header_size,\n                              const char* range_start,\n                              const char* range_end);\n\n  // Parse pickle header and return total size of the pickle. Data range\n  // doesn't need to contain entire pickle.\n  // Returns true if pickle header was found and parsed. Callers must check\n  // returned |pickle_size| for sanity (against maximum message size, etc).\n  // NOTE: when function successfully parses a header, but encounters an\n  // overflow during pickle size calculation, it sets |pickle_size| to the\n  // maximum size_t value and returns true.\n  static bool PeekNext(size_t header_size,\n                       const char* range_start,\n                       const char* range_end,\n                       size_t* pickle_size);\n\n  // The allocation granularity of the payload.\n  static const int kPayloadUnit;\n\n private:\n  friend class PickleIterator;\n\n  Header* header_;\n  size_t header_size_;  // Supports extra data between header and payload.\n  // Allocation size of payload (or -1 if allocation is const). Note: this\n  // doesn't count the header.\n  size_t capacity_after_header_;\n  // The offset at which we will write the next field. Note: this doesn't count\n  // the header.\n  size_t write_offset_;\n\n  // Just like WriteBytes, but with a compile-time size, for performance.\n  template\u003csize_t length\u003e void BASE_EXPORT WriteBytesStatic(const void* data);\n\n  // Writes a POD by copying its bytes.\n  template \u003ctypename T\u003e bool WritePOD(const T\u0026 data) {\n    WriteBytesStatic\u003csizeof(data)\u003e(\u0026data);\n    return true;\n  }\n\n  inline void* ClaimUninitializedBytesInternal(size_t num_bytes);\n  inline void WriteBytesCommon(const void* data, size_t length);\n\n  FRIEND_TEST_ALL_PREFIXES(PickleTest, DeepCopyResize);\n  FRIEND_TEST_ALL_PREFIXES(PickleTest, Resize);\n  FRIEND_TEST_ALL_PREFIXES(PickleTest, PeekNext);\n  FRIEND_TEST_ALL_PREFIXES(PickleTest, PeekNextOverflow);\n  FRIEND_TEST_ALL_PREFIXES(PickleTest, FindNext);\n  FRIEND_TEST_ALL_PREFIXES(PickleTest, FindNextWithIncompleteHeader);\n  FRIEND_TEST_ALL_PREFIXES(PickleTest, FindNextOverflow);\n};\n\n}  // namespace base\n\n#endif  // BASE_PICKLE_H_\n"},"gob_info":{"repo":"chromium/chromium/src","commit":"65dcbb2ab5805377de065aaa1dbc87215df460f7","path":"base/pickle.h"}}}],"elapsed_ms":95}