{"file_info_response":[{"return_code":1,"file_info":{"name":"src/url/gurl.h","lines":"476","size":"19285","language":"c++","type":1,"md5":"e41d892356bd8ed91580c9b58aaaa64b","changelist_num":"ea3fb69a9bb9ce86d98fa6f9cabe6084a739fdf5","mime_type":"text/plain","generated":false,"package_name":"chromium","content":{"text":"// Copyright 2013 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef URL_GURL_H_\n#define URL_GURL_H_\n\n#include \u003cstddef.h\u003e\n\n#include \u003ciosfwd\u003e\n#include \u003cmemory\u003e\n#include \u003cstring\u003e\n\n#include \"base/strings/string16.h\"\n#include \"base/strings/string_piece.h\"\n#include \"url/third_party/mozilla/url_parse.h\"\n#include \"url/url_canon.h\"\n#include \"url/url_canon_stdstring.h\"\n#include \"url/url_constants.h\"\n#include \"url/url_export.h\"\n\n// Represents a URL.\n//\n// A parsed canonicalized URL will be guaranteed UTF-8. Only the ref (if\n// specified) can be non-ASCII, the host, path, etc. will be guaranteed ASCII\n// and any non-ASCII characters will be encoded and % escaped.\n//\n// The string representation of a URL is called the spec(). Getting the\n// spec will assert if the URL is invalid to help protect against malicious\n// URLs. If you want the \"best effort\" canonicalization of an invalid URL, you\n// can use possibly_invalid_spec(). Test validity with is_valid(). Data and\n// javascript URLs use GetContent() to extract the data.\n//\n// This class has existence checkers and getters for the various components of\n// a URL. Existence is different than being nonempty. \"http://www.google.com/?\"\n// has a query that just happens to be empty, and has_query() will return true\n// while the query getters will return the empty string.\n//\n// Prefer not to modify a URL using string operations (though sometimes this is\n// unavoidable). Instead, use ReplaceComponents which can replace or delete\n// multiple parts of a URL in one step, doesn't re-canonicalize unchanged\n// sections, and avoids some screw-ups. An example is creating a URL with a\n// path that contains a literal '#'. Using string concatenation will generate a\n// URL with a truncated path and a reference fragment, while ReplaceComponents\n// will know to escape this and produce the desired result.\nclass URL_EXPORT GURL {\n public:\n  typedef url::StringPieceReplacements\u003cstd::string\u003e Replacements;\n  typedef url::StringPieceReplacements\u003cbase::string16\u003e ReplacementsW;\n\n  // Creates an empty, invalid URL.\n  GURL();\n\n  // Copy construction is relatively inexpensive, with most of the time going\n  // to reallocating the string. It does not re-parse.\n  GURL(const GURL\u0026 other);\n  GURL(GURL\u0026\u0026 other) noexcept;\n\n  // The strings to this contructor should be UTF-8 / UTF-16.\n  explicit GURL(base::StringPiece url_string);\n  explicit GURL(base::StringPiece16 url_string);\n\n  // Constructor for URLs that have already been parsed and canonicalized. This\n  // is used for conversions from KURL, for example. The caller must supply all\n  // information associated with the URL, which must be correct and consistent.\n  GURL(const char* canonical_spec,\n       size_t canonical_spec_len,\n       const url::Parsed\u0026 parsed,\n       bool is_valid);\n  // Notice that we take the canonical_spec by value so that we can convert\n  // from WebURL without copying the string. When we call this constructor\n  // we pass in a temporary std::string, which lets the compiler skip the\n  // copy and just move the std::string into the function argument. In the\n  // implementation, we use std::move to move the data into the GURL itself,\n  // which means we end up with zero copies.\n  GURL(std::string canonical_spec, const url::Parsed\u0026 parsed, bool is_valid);\n\n  ~GURL();\n\n  GURL\u0026 operator=(const GURL\u0026 other);\n  GURL\u0026 operator=(GURL\u0026\u0026 other);\n\n  // Returns true when this object represents a valid parsed URL. When not\n  // valid, other functions will still succeed, but you will not get canonical\n  // data out in the format you may be expecting. Instead, we keep something\n  // \"reasonable looking\" so that the user can see how it's busted if\n  // displayed to them.\n  bool is_valid() const {\n    return is_valid_;\n  }\n\n  // Returns true if the URL is zero-length. Note that empty URLs are also\n  // invalid, and is_valid() will return false for them. This is provided\n  // because some users may want to treat the empty case differently.\n  bool is_empty() const {\n    return spec_.empty();\n  }\n\n  // Returns the raw spec, i.e., the full text of the URL, in canonical UTF-8,\n  // if the URL is valid. If the URL is not valid, this will assert and return\n  // the empty string (for safety in release builds, to keep them from being\n  // misused which might be a security problem).\n  //\n  // The URL will be ASCII except the reference fragment, which may be UTF-8.\n  // It is guaranteed to be valid UTF-8.\n  //\n  // The exception is for empty() URLs (which are !is_valid()) but this will\n  // return the empty string without asserting.\n  //\n  // Used invalid_spec() below to get the unusable spec of an invalid URL. This\n  // separation is designed to prevent errors that may cause security problems\n  // that could result from the mistaken use of an invalid URL.\n  const std::string\u0026 spec() const;\n\n  // Returns the potentially invalid spec for a the URL. This spec MUST NOT be\n  // modified or sent over the network. It is designed to be displayed in error\n  // messages to the user, as the appearance of the spec may explain the error.\n  // If the spec is valid, the valid spec will be returned.\n  //\n  // The returned string is guaranteed to be valid UTF-8.\n  const std::string\u0026 possibly_invalid_spec() const {\n    return spec_;\n  }\n\n  // Getter for the raw parsed structure. This allows callers to locate parts\n  // of the URL within the spec themselves. Most callers should consider using\n  // the individual component getters below.\n  //\n  // The returned parsed structure will reference into the raw spec, which may\n  // or may not be valid. If you are using this to index into the spec, BE\n  // SURE YOU ARE USING possibly_invalid_spec() to get the spec, and that you\n  // don't do anything \"important\" with invalid specs.\n  const url::Parsed\u0026 parsed_for_possibly_invalid_spec() const {\n    return parsed_;\n  }\n\n  // Allows GURL to used as a key in STL (for example, a std::set or std::map).\n  bool operator\u003c(const GURL\u0026 other) const;\n  bool operator\u003e(const GURL\u0026 other) const;\n\n  // Resolves a URL that's possibly relative to this object's URL, and returns\n  // it. Absolute URLs are also handled according to the rules of URLs on web\n  // pages.\n  //\n  // It may be impossible to resolve the URLs properly. If the input is not\n  // \"standard\" (IsStandard() == false) and the input looks relative, we can't\n  // resolve it. In these cases, the result will be an empty, invalid GURL.\n  //\n  // The result may also be a nonempty, invalid URL if the input has some kind\n  // of encoding error. In these cases, we will try to construct a \"good\" URL\n  // that may have meaning to the user, but it will be marked invalid.\n  //\n  // It is an error to resolve a URL relative to an invalid URL. The result\n  // will be the empty URL.\n  GURL Resolve(const std::string\u0026 relative) const;\n  GURL Resolve(const base::string16\u0026 relative) const;\n\n  // Creates a new GURL by replacing the current URL's components with the\n  // supplied versions. See the Replacements class in url_canon.h for more.\n  //\n  // These are not particularly quick, so avoid doing mutations when possible.\n  // Prefer the 8-bit version when possible.\n  //\n  // It is an error to replace components of an invalid URL. The result will\n  // be the empty URL.\n  //\n  // Note that we use the more general url::Replacements type to give\n  // callers extra flexibility rather than our override.\n  GURL ReplaceComponents(const url::Replacements\u003cchar\u003e\u0026 replacements) const;\n  GURL ReplaceComponents(\n      const url::Replacements\u003cbase::char16\u003e\u0026 replacements) const;\n\n  // A helper function that is equivalent to replacing the path with a slash\n  // and clearing out everything after that. We sometimes need to know just the\n  // scheme and the authority. If this URL is not a standard URL (it doesn't\n  // have the regular authority and path sections), then the result will be\n  // an empty, invalid GURL. Note that this *does* work for file: URLs, which\n  // some callers may want to filter out before calling this.\n  //\n  // It is an error to get an empty path on an invalid URL. The result\n  // will be the empty URL.\n  GURL GetWithEmptyPath() const;\n\n  // A helper function to return a GURL containing just the scheme, host,\n  // and port from a URL. Equivalent to clearing any username and password,\n  // replacing the path with a slash, and clearing everything after that. If\n  // this URL is not a standard URL, then the result will be an empty,\n  // invalid GURL. If the URL has neither username nor password, this\n  // degenerates to GetWithEmptyPath().\n  //\n  // It is an error to get the origin of an invalid URL. The result\n  // will be the empty URL.\n  GURL GetOrigin() const;\n\n  // A helper function to return a GURL stripped from the elements that are not\n  // supposed to be sent as HTTP referrer: username, password and ref fragment.\n  // For invalid URLs or URLs that no valid referrers, an empty URL will be\n  // returned.\n  GURL GetAsReferrer() const;\n\n  // Returns true if the scheme for the current URL is a known \"standard-format\"\n  // scheme. A standard-format scheme adheres to what RFC 3986 calls \"generic\n  // URI syntax\" (https://tools.ietf.org/html/rfc3986#section-3). This includes\n  // file: and filesystem:, which some callers may want to filter out explicitly\n  // by calling SchemeIsFile[System].\n  bool IsStandard() const;\n\n  // Returns true when the url is of the form about:blank, about:blank?foo or\n  // about:blank/#foo.\n  bool IsAboutBlank() const;\n\n  // Returns true if the given parameter (should be lower-case ASCII to match\n  // the canonicalized scheme) is the scheme for this URL. Do not include a\n  // colon.\n  bool SchemeIs(base::StringPiece lower_ascii_scheme) const;\n\n  // Returns true if the scheme is \"http\" or \"https\".\n  bool SchemeIsHTTPOrHTTPS() const;\n\n  // Returns true if the scheme is valid for use as a referrer.\n  bool SchemeIsValidForReferrer() const;\n\n  // Returns true is the scheme is \"ws\" or \"wss\".\n  bool SchemeIsWSOrWSS() const;\n\n  // We often need to know if this is a file URL. File URLs are \"standard\", but\n  // are often treated separately by some programs.\n  bool SchemeIsFile() const {\n    return SchemeIs(url::kFileScheme);\n  }\n\n  // FileSystem URLs need to be treated differently in some cases.\n  bool SchemeIsFileSystem() const {\n    return SchemeIs(url::kFileSystemScheme);\n  }\n\n  // Returns true if the scheme indicates a network connection that uses TLS or\n  // some other cryptographic protocol (e.g. QUIC) for security.\n  //\n  // This function is a not a complete test of whether or not an origin's code\n  // is minimally trustworthy. For that, see Chromium's |IsOriginSecure| for a\n  // higher-level and more complete semantics. See that function's documentation\n  // for more detail.\n  bool SchemeIsCryptographic() const {\n    return SchemeIs(url::kHttpsScheme) || SchemeIs(url::kWssScheme) ||\n           SchemeIs(url::kHttpsSuboriginScheme);\n  }\n\n  // Returns true if the scheme is \"blob\".\n  bool SchemeIsBlob() const {\n    return SchemeIs(url::kBlobScheme);\n  }\n\n  // Returns true if the scheme indicates a serialized suborigin.\n  bool SchemeIsSuborigin() const {\n    return SchemeIs(url::kHttpSuboriginScheme) ||\n           SchemeIs(url::kHttpsSuboriginScheme);\n  }\n\n  // The \"content\" of the URL is everything after the scheme (skipping the\n  // scheme delimiting colon). It is an error to get the content of an invalid\n  // URL: the result will be an empty string.\n  std::string GetContent() const;\n\n  // Returns true if the hostname is an IP address. Note: this function isn't\n  // as cheap as a simple getter because it re-parses the hostname to verify.\n  bool HostIsIPAddress() const;\n\n  // Not including the colon. If you are comparing schemes, prefer SchemeIs.\n  bool has_scheme() const {\n    return parsed_.scheme.len \u003e= 0;\n  }\n  std::string scheme() const {\n    return ComponentString(parsed_.scheme);\n  }\n  base::StringPiece scheme_piece() const {\n    return ComponentStringPiece(parsed_.scheme);\n  }\n\n  bool has_username() const {\n    return parsed_.username.len \u003e= 0;\n  }\n  std::string username() const {\n    return ComponentString(parsed_.username);\n  }\n  base::StringPiece username_piece() const {\n    return ComponentStringPiece(parsed_.username);\n  }\n\n  bool has_password() const {\n    return parsed_.password.len \u003e= 0;\n  }\n  std::string password() const {\n    return ComponentString(parsed_.password);\n  }\n  base::StringPiece password_piece() const {\n    return ComponentStringPiece(parsed_.password);\n  }\n\n  // The host may be a hostname, an IPv4 address, or an IPv6 literal surrounded\n  // by square brackets, like \"[2001:db8::1]\". To exclude these brackets, use\n  // HostNoBrackets() below.\n  bool has_host() const {\n    // Note that hosts are special, absence of host means length 0.\n    return parsed_.host.len \u003e 0;\n  }\n  std::string host() const {\n    return ComponentString(parsed_.host);\n  }\n  base::StringPiece host_piece() const {\n    return ComponentStringPiece(parsed_.host);\n  }\n\n  // The port if one is explicitly specified. Most callers will want IntPort()\n  // or EffectiveIntPort() instead of these. The getters will not include the\n  // ':'.\n  bool has_port() const {\n    return parsed_.port.len \u003e= 0;\n  }\n  std::string port() const {\n    return ComponentString(parsed_.port);\n  }\n  base::StringPiece port_piece() const {\n    return ComponentStringPiece(parsed_.port);\n  }\n\n  // Including first slash following host, up to the query. The URL\n  // \"http://www.google.com/\" has a path of \"/\".\n  bool has_path() const {\n    return parsed_.path.len \u003e= 0;\n  }\n  std::string path() const {\n    return ComponentString(parsed_.path);\n  }\n  base::StringPiece path_piece() const {\n    return ComponentStringPiece(parsed_.path);\n  }\n\n  // Stuff following '?' up to the ref. The getters will not include the '?'.\n  bool has_query() const {\n    return parsed_.query.len \u003e= 0;\n  }\n  std::string query() const {\n    return ComponentString(parsed_.query);\n  }\n  base::StringPiece query_piece() const {\n    return ComponentStringPiece(parsed_.query);\n  }\n\n  // Stuff following '#' to the end of the string. This will be UTF-8 encoded\n  // (not necessarily ASCII). The getters will not include the '#'.\n  bool has_ref() const {\n    return parsed_.ref.len \u003e= 0;\n  }\n  std::string ref() const {\n    return ComponentString(parsed_.ref);\n  }\n  base::StringPiece ref_piece() const {\n    return ComponentStringPiece(parsed_.ref);\n  }\n\n  // Returns a parsed version of the port. Can also be any of the special\n  // values defined in Parsed for ExtractPort.\n  int IntPort() const;\n\n  // Returns the port number of the URL, or the default port number.\n  // If the scheme has no concept of port (or unknown default) returns\n  // PORT_UNSPECIFIED.\n  int EffectiveIntPort() const;\n\n  // Extracts the filename portion of the path and returns it. The filename\n  // is everything after the last slash in the path. This may be empty.\n  std::string ExtractFileName() const;\n\n  // Returns the path that should be sent to the server. This is the path,\n  // parameter, and query portions of the URL. It is guaranteed to be ASCII.\n  std::string PathForRequest() const;\n\n  // Returns the host, excluding the square brackets surrounding IPv6 address\n  // literals. This can be useful for passing to getaddrinfo().\n  std::string HostNoBrackets() const;\n\n  // Returns true if this URL's host matches or is in the same domain as\n  // the given input string. For example, if the hostname of the URL is\n  // \"www.google.com\", this will return true for \"com\", \"google.com\", and\n  // \"www.google.com\".\n  //\n  // The input domain should be lower-case ASCII to match the canonicalized\n  // scheme. This call is more efficient than getting the host and check\n  // whether host has the specific domain or not because no copies or\n  // object constructions are done.\n  bool DomainIs(base::StringPiece lower_ascii_domain) const;\n\n  // Checks whether or not two URLs are differing only in the ref (the part\n  // after the # character).\n  bool EqualsIgnoringRef(const GURL\u0026 other) const;\n\n  // Swaps the contents of this GURL object with |other|, without doing\n  // any memory allocations.\n  void Swap(GURL* other);\n\n  // Returns a reference to a singleton empty GURL. This object is for callers\n  // who return references but don't have anything to return in some cases.\n  // If you just want an empty URL for normal use, prefer GURL(). This function\n  // may be called from any thread.\n  static const GURL\u0026 EmptyGURL();\n\n  // Returns the inner URL of a nested URL (currently only non-null for\n  // filesystem URLs).\n  //\n  // TODO(mmenke): inner_url().spec() currently returns the same value as\n  // caling spec() on the GURL itself. This should be fixed.\n  // See https://crbug.com/619596\n  const GURL* inner_url() const {\n    return inner_url_.get();\n  }\n\n  // Estimates dynamic memory usage.\n  // See base/trace_event/memory_usage_estimator.h for more info.\n  size_t EstimateMemoryUsage() const;\n\n private:\n  // Variant of the string parsing constructor that allows the caller to elect\n  // retain trailing whitespace, if any, on the passed URL spec, but only if\n  // the scheme is one that allows trailing whitespace. The primary use-case is\n  // for data: URLs. In most cases, you want to use the single parameter\n  // constructor above.\n  enum RetainWhiteSpaceSelector { RETAIN_TRAILING_PATH_WHITEPACE };\n  GURL(const std::string\u0026 url_string, RetainWhiteSpaceSelector);\n\n  template\u003ctypename STR\u003e\n  void InitCanonical(base::BasicStringPiece\u003cSTR\u003e input_spec,\n                     bool trim_path_end);\n\n  void InitializeFromCanonicalSpec();\n\n  // Returns the substring of the input identified by the given component.\n  std::string ComponentString(const url::Component\u0026 comp) const {\n    if (comp.len \u003c= 0)\n      return std::string();\n    return std::string(spec_, comp.begin, comp.len);\n  }\n  base::StringPiece ComponentStringPiece(const url::Component\u0026 comp) const {\n    if (comp.len \u003c= 0)\n      return base::StringPiece();\n    return base::StringPiece(\u0026spec_[comp.begin], comp.len);\n  }\n\n  // The actual text of the URL, in canonical ASCII form.\n  std::string spec_;\n\n  // Set when the given URL is valid. Otherwise, we may still have a spec and\n  // components, but they may not identify valid resources (for example, an\n  // invalid port number, invalid characters in the scheme, etc.).\n  bool is_valid_;\n\n  // Identified components of the canonical spec.\n  url::Parsed parsed_;\n\n  // Used for nested schemes [currently only filesystem:].\n  std::unique_ptr\u003cGURL\u003e inner_url_;\n};\n\n// Stream operator so GURL can be used in assertion statements.\nURL_EXPORT std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 out, const GURL\u0026 url);\n\nURL_EXPORT bool operator==(const GURL\u0026 x, const GURL\u0026 y);\nURL_EXPORT bool operator!=(const GURL\u0026 x, const GURL\u0026 y);\n\n// Equality operator for comparing raw spec_. This should be used in place of\n// url == GURL(spec) where |spec| is known (i.e. constants). This is to prevent\n// needlessly re-parsing |spec| into a temporary GURL.\nURL_EXPORT bool operator==(const GURL\u0026 x, const base::StringPiece\u0026 spec);\nURL_EXPORT bool operator!=(const GURL\u0026 x, const base::StringPiece\u0026 spec);\n\n#endif  // URL_GURL_H_\n"},"gob_info":{"repo":"chromium/chromium/src","commit":"ea3fb69a9bb9ce86d98fa6f9cabe6084a739fdf5","path":"url/gurl.h"}}}],"elapsed_ms":32}